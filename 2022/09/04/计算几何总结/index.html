<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 引言计算几何计算机科学的一个重要分支，因此在算法竞赛中也是常考的一类题，难度从签到题到防AK题不等。本文是作者对计算几何在算法竞赛中的解题学应用的一点心得，主要介绍计算几何专题内比较经典的思想，算法和个人对此的一点心得。本文从逻辑上分为三个部分，第一部分是阐释解决有关计算几何算法问题时的设计思想，第二部分从点，向量，圆，三角，简单多边形等计算几何中主要处理的二维图像的角度出发，用面向对象的思想">
<meta property="og:type" content="article">
<meta property="og:title" content="计算几何总结">
<meta property="og:url" content="http://example.com/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Sanshuiii">
<meta property="og:description" content="1 引言计算几何计算机科学的一个重要分支，因此在算法竞赛中也是常考的一类题，难度从签到题到防AK题不等。本文是作者对计算几何在算法竞赛中的解题学应用的一点心得，主要介绍计算几何专题内比较经典的思想，算法和个人对此的一点心得。本文从逻辑上分为三个部分，第一部分是阐释解决有关计算几何算法问题时的设计思想，第二部分从点，向量，圆，三角，简单多边形等计算几何中主要处理的二维图像的角度出发，用面向对象的思想">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200507202419129.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200508094631559.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200508120139593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200508120656917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200508123202396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200508123238601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2022-09-04T12:34:48.000Z">
<meta property="article:modified_time" content="2022-09-04T12:35:20.541Z">
<meta property="article:author" content="Yifan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200507202419129.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="http://example.com/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算几何总结 | Sanshuiii</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sanshuiii</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算几何总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:34:48 / Modified: 16:35:20" itemprop="dateCreated datePublished" datetime="2022-09-04T16:34:48+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>计算几何计算机科学的一个重要分支，因此在算法竞赛中也是常考的一类题，难度从签到题到防AK题不等。本文是作者对计算几何在算法竞赛中的解题学应用的一点心得，主要介绍计算几何专题内比较经典的思想，算法和个人对此的一点心得。本文从逻辑上分为三个部分，第一部分是阐释解决有关计算几何算法问题时的设计思想，第二部分从点，向量，圆，三角，简单多边形等计算几何中主要处理的二维图像的角度出发，用面向对象的思想介绍类成员函数和成员变量（但是出于程序实现的方便，在设计程序时依然以面向过程为主），主要采用的手段仍然以解析几何为主。最后介绍非解析方法的数值计算技巧，用以解决一类其他的问题。本文将围绕问题转化，分类讨论等算法设计中常用的思想对上述内容进行阐释。</p>
<h3 id="1-1-精度"><a href="#1-1-精度" class="headerlink" title="1.1 精度"></a>1.1 精度</h3><p>在以解析几何为理论背景的计算几何问题中，精度对程序正确性的影响非常大，其中尤其以开根操作和三角函数操作影响恶劣。此外，受限于计算机存储空间有限性，在逻辑上无法直接存储无尽小数（不考虑分数类等间接表示的方法），所以在经过一系列操作后<code>==</code>操作符可能无法判断逻辑上等价而数值上不等价的表达式。</p>
<p>关于精度，主要就是要解决上述两个问题：精度降低和因此带来的等价判断处理。</p>
<p>第一个问题目前还没有很好的办法解决，在部分不需要非线性运算的问题中，可以用分数类来实现逻辑上的精确表述，在输出结果前不会产生精度损失。但是当遇到开根，三角函数等精度杀手时，分数类就显得力不从心了。一般而言，当精度要求为 $10^{-6}$ 时，可以容忍一次到二次开根操作或者一次(反)三角函数运算。使用<code>long double</code>可以略微提升精度，但是效果不明显。</p>
<p>在等价判断上，一般设一个所需精度级别的误差量，当两个数之差小于该误差量时，可以认为这两个数相等。因为这最多带来小于所需精度级别的误差，基本可以认为他是安全的。当该操作后还要套很多操作时，可以适当减小这个误差量。使用一个<code>cmp</code>函数来实现比较功能，返回值类似<code>java</code>中的 <code>compareTo</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> EPS=<span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;a,<span class="type">const</span> <span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;EPS)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个常用的手段是用<code>long long</code>存储数据。在处理不涉及距离，面积的问题时(或者只在最后一步求)，如凸包(只需要处理叉积)，可以判断性的操作都在整数范围下完成，只在计算距离面积数值时才转换为浮点型计算。这样可以有效避免各种浮点误差。</p>
<h3 id="1-2-剖分"><a href="#1-2-剖分" class="headerlink" title="1.2 剖分"></a>1.2 剖分</h3><p>在非算法竞赛中说的三角剖分，常指在一个简单多边形的顶点间连若干条互不相交的线段，将之分解成若干个三角形，从而对于多边形的面积，重心，面积交等问题时可以通过这些三角形间接求出来。这本质上是一种转换的思想，将不好处理的多边形，转换为熟悉的三角形，在三角形上进行分类讨论来解决各类实际问题。</p>
<p>但是这种做法在实现时非常复杂，先要用扫描线法进行单调多边形的划分，然后再在单调多边形上用扫描线法求出三角剖分，编程复杂度巨大。</p>
<p>考虑一个更加简便的做法，在求面积的情况下，本质上是对三角形面积的加和。当三角剖分没有相交时，出现的所有三角形都对结果贡献了正面积。在这里我们考虑负面积，对于一个枢轴点 $O$ , 有多边形 $P$ 面积为 $\sum_{i\in P}\vec{op_i}\times\vec{op_{i+1}}$ 。当叉乘结果为负时，则对结果贡献负面积，最终结果和不相交的三角剖分一致。这样，在处理和面积相关的问题时，对正负面积分别累计，就可以得到一个更加高效的三角剖分的解法。</p>
<h3 id="1-3-层次化设计"><a href="#1-3-层次化设计" class="headerlink" title="1.3 层次化设计"></a>1.3 层次化设计</h3><p>在设计程序时，建议对处理的对象进行逐级的定义和初始化，因为计算几何问题往往有着很强的层次性，如多边形在进行三角剖分后处理时，往往需要调用线段之间的操作，而此操作又依赖于点和向量的操作。从简单的几何结构及其操作开始定义，逐步搭建更高级的结构，可以有效降低编程过程中的复杂性。</p>
<h2 id="2-点，向量和线"><a href="#2-点，向量和线" class="headerlink" title="2 点，向量和线"></a>2 点，向量和线</h2><p>二维平面上的点和向量都可以用一个二元组来表示，事实上点坐标可以视为一个原点上引出的向量，所以可以将点和向量设计为同一种结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    point <span class="keyword">operator</span>+(<span class="type">const</span> point &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+obj.x,y+obj.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span>-(<span class="type">const</span> point &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-obj.x,y-obj.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">norm</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y+<span class="number">0.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">norm2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*x+y*y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a-b).<span class="built_in">norm</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-点积和叉积"><a href="#2-1-点积和叉积" class="headerlink" title="2.1 点积和叉积"></a>2.1 点积和叉积</h3><p>在计算几何中，向量的点积和叉积是有效的判断方向的手段，在只需要定性而不需要定量的向量朝向分析时，点积和叉积可以胜任绝大多数求角度&#x2F;求斜率操作能求解的问题。<br><img src="https://img-blog.csdnimg.cn/20200507202419129.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图2.1.1"><br>使用叉积可以判断给定向量在原向量基础上左偏还是右偏，使用点积可以判断给定向量和原向量正向还是反向。不难发现，点积满足交换率，而叉积不满足交换律。</p>
<p>规定 $\times (det)$ 表示叉积 $· (dot)$ 表示点积，有二维语境下的定义如下：</p>
<p>$$\vec{a}\times\vec{b} &#x3D; a.x  * b.y - a.y <em>b.x &#x3D; |a|</em>|b|*sin&lt;\vec{a},\vec{b}&gt;$$</p>
<p>$$\vec{a}  · \vec{b} &#x3D; a.x  * b.x + a.y <em>b.y &#x3D; |a|</em>|b|*cos&lt;\vec{a},\vec{b}&gt; $$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">det</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">det</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">det</span>(a-o,b-o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.x+a.y*b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(a-o,b-o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，不难发现叉积的绝对值同时是两向量构成的四边形的面积，所以可以通过叉积快速求出三角形面积。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfTriangle</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b,<span class="type">const</span> point &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">det</span>(a,b,c)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-线段-直线"><a href="#2-2-线段-直线" class="headerlink" title="2.2 线段(直线)"></a>2.2 线段(直线)</h3><p>线段主要有四种储存方式，两点式，点向式，一般式，斜率式。</p>
<p>一般都以两点式存储，因为其不受斜率限制，可以表示任意一条直线，并且可以表示线段的范围，优势比较明显，此外还可以表示方向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span>&#123;</span><br><span class="line">	point s,t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在计算方程时，斜率式和一般式更为常用，尤其联立解一次以上方程时，常用斜率式，此时需要注意确认是否是铅直线，以防出现除<code>0</code>的<code>RE</code>。</p>
<p>对于两点式 $l(s,t)$，若 $s.x&#x3D;&#x3D;t.x$ 则为铅直线，需要另行讨论；否则有：</p>
<p>$$k&#x3D;\frac{(s.y-t.y)}{(s.x-t.x)}$$</p>
<p>$$b&#x3D;s.y-k*s.x$$</p>
<p>如此便可以从两点式转换为斜率式，反过来处理只需代入端点计算即可。至于两点式和点向式的转换，斜率式和一般式的转换，都较为简单，此处不表。一般而言，我们所说的直线均默认以两点式存储。</p>
<h4 id="2-2-1-点在线段上判定"><a href="#2-2-1-点在线段上判定" class="headerlink" title="2.2.1 点在线段上判定"></a>2.2.1 点在线段上判定</h4><p>点在线段上等价于</p>
<ul>
<li>点在对应直线上</li>
<li>点的横纵坐标在对应范围内</li>
</ul>
<p>一般而言，在处理问题时，如图形交点，常用直线先求出所有交点，再判断是否在所求线段上，所以第一条条件一般总是满足。大多数情况下只要快速判断第二条即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPointOnSegment</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> mix=<span class="built_in">min</span>(l.s.x,l.t.x);</span><br><span class="line">	<span class="type">double</span> mxx=<span class="built_in">max</span>(l.s.x,l.t.x);</span><br><span class="line">	<span class="type">double</span> miy=<span class="built_in">min</span>(l.s.y,l.t.y);</span><br><span class="line">	<span class="type">double</span> mxy=<span class="built_in">max</span>(l.s.y,l.t.y);</span><br><span class="line">    <span class="keyword">return</span> mix&lt;=o.x&amp;&amp;o.x&lt;=mxx&amp;&amp;miy&lt;=o.y&amp;&amp;o.y&lt;=mxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-线线交求交点"><a href="#2-2-2-线线交求交点" class="headerlink" title="2.2.2 线线交求交点"></a>2.2.2 线线交求交点</h4><p>如果是直线，直接转为一般式求解即可。如果是线段，只要在此基础上加上点在线段上判定即可。需要说明的是有必要特判斜率不存在的特殊情况。<del>一个玄学的处理方法是开始对所有点旋转一个特定角度以卡掉铅直线，避免讨论。</del> </p>
<h4 id="2-2-3-线线交判定"><a href="#2-2-3-线线交判定" class="headerlink" title="2.2.3 线线交判定"></a>2.2.3 线线交判定</h4><p>此处判定特指线段交，因为在欧氏二维空间中，直线不平行必定相交。可以用上述方法进行大讨论，也可以采用快速排斥+跨立实验的方法。</p>
<p>快速排斥实验指：判断两线段所在平行于坐标轴的矩形是否相交。</p>
<p>跨立实验指是指：判断对任意一条线段，另一线段两端点是否在其两侧。</p>
<p>需要说明的是，如果不能通过跨立实验，说明那么必定不可能相交；如果通过夸跨立实验而不通过快速排斥实验，则说明两条直线共线且有交点。</p>
<p>该判定方法有较多文字资料，可以自行查阅。</p>
<h4 id="2-2-4-点线距"><a href="#2-2-4-点线距" class="headerlink" title="2.2.4 点线距"></a>2.2.4 点线距</h4><p>点到直线距离有一般式公式：<br>$$d&#x3D;\frac{|Ax+By+C|}{\sqrt{x^2+y^2}}$$</p>
<p>但是这种写法需要对两点式进行变形，较为麻烦，一般采用面积除以底的形式，利用叉积的性质可以直接得到点 $O$ 到线段 $A,B$ 的距离：<br>$$d&#x3D;\frac{\vec{OA}\times\vec{OB}}{|\vec{AB}|}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">det</span>(o,l.s,l.t)/<span class="built_in">dis</span>(l.s,l.t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-圆和三角函数"><a href="#3-圆和三角函数" class="headerlink" title="3 圆和三角函数"></a>3 圆和三角函数</h2><p>圆往往和角度有关，所以在本节中，将圆和三角函数放在一起进行讨论。</p>
<p>圆心和半径可以唯一确定一个圆，因此给出圆的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">    point cn;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便起见，在本节中，如无特殊说明，所有的角度均为弧度制。</p>
<h3 id="3-1-正弦定理和余弦定理"><a href="#3-1-正弦定理和余弦定理" class="headerlink" title="3.1 正弦定理和余弦定理"></a>3.1 正弦定理和余弦定理</h3><p>在诸如X点共圆的题目中，求圆心角是一个常见操作。圆心角的一个更一般的表述是，对于给定一点引出的两条向量，求他们之间的夹角(即三角形内角)。<br><img src="https://img-blog.csdnimg.cn/20200508094631559.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图3.1.1"><br>用余弦定理可以容易的得到三角函数值：<br>$$\cos\theta&#x3D;\frac{a^2+b^2-c^2}{2ab}$$<br>如果已知各点均在圆上，在等腰三角形的情况下，可以用正弦定理解三角方程：<br>$$\frac{\sin\theta}{c}&#x3D;\frac{\sin(\frac{\pi-\theta}{2})}{r}$$<br>当然，直接通过叉积和点积求三角函数也可以，精度相差不大。</p>
<h3 id="3-2-反三角函数求角度"><a href="#3-2-反三角函数求角度" class="headerlink" title="3.2 反三角函数求角度"></a>3.2 反三角函数求角度</h3><p>求角度一般而言都绕不过反三角函数，所以角度和图形的转换势必会有较大的精度损失，建议尽量减少求角度的操作。在使用反三角函数时，一般使用<code>acos</code>而不是用<code>asin</code>，因为<code>acos</code>的值域为 $[0,\pi]$<br>，而<code>asin</code>的值域为 $[-\frac{\pi}{2},\frac{\pi}{2}]$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="number">1.0</span>*<span class="built_in">dot</span>(o,a,b)/<span class="built_in">dis</span>(a,o)/<span class="built_in">dis</span>(b,o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了减少求三角函数过程中求向量模长带来的精度损失，也可以使用<code>atan2</code>减少一步开根操作，提高精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	point da=a-o;</span><br><span class="line">	point db=b-o;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>(<span class="number">1.0</span>*da.y,<span class="number">1.0</span>*da.x)-<span class="built_in">atan2</span>(<span class="number">1.0</span>*db.y,<span class="number">1.0</span>*db.x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后一种做法的好处不止在于精度，而且去掉<code>fabs</code>后还可以得到有向的角度，适用性更广泛。劣势在于不能同时得到三角函数值。</p>
<h3 id="3-3-扇形面积"><a href="#3-3-扇形面积" class="headerlink" title="3.3 扇形面积"></a>3.3 扇形面积</h3><p>以下两节是圆操作中比较基础的内容，多见于多边形和圆面积交的前置操作。</p>
<p>扇形面积比较简单，有类似三角形的面积公式<br>$$S&#x3D;\frac{RL}{2}&#x3D;\frac{L^2\alpha}{2}$$<br>其中半径为 $R$ 弧长为 $L$，有对应弧度为 $\alpha&#x3D;\frac{L}{R}$。</p>
<p>这样直接调用上一节的角度公式即可求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfSector</span><span class="params">(<span class="type">const</span> circle &amp;c,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">angle</span>(c.cn,a,b)*c.r*c.r/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-圆和线段交"><a href="#3-4-圆和线段交" class="headerlink" title="3.4 圆和线段交"></a>3.4 圆和线段交</h3><p>圆和线段很不好交，因为线段有长度限制。比较好的处理方法是先和直线交，再判断是否在线段上，调用2.2.1节的判定函数。</p>
<p>判断关于直线解个数可以直接用圆心距判断，求交点则可以联立解方程(解方程时的<code>delta</code>值也可以直接用来判断解个数)。</p>
<p>作者尝试过使用向量做法解交点，但是因为在求解过程中大量使用开根操作(向量模)对向量进行缩放，导致巨大精度损失，所以建议还是使用丑陋的斜率式方程求解，特判垂直情况。在上交的算法书里，介绍了一种点向式带入圆方程的解法，也不失为一种巧妙的解法，用向量规避了无意义的斜率不存在的讨论，同时又利用解析方法避免纯向量方法频繁求模长带来的开根精度损失。</p>
<h4 id="3-4-1-点斜式解法"><a href="#3-4-1-点斜式解法" class="headerlink" title="3.4.1 点斜式解法"></a>3.4.1 点斜式解法</h4><p>因为这里涉及到求交点问题，所以在上面point类中应该将成员函数定义为double。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">polygon <span class="title">circleIntersectSegment</span><span class="params">(<span class="type">const</span> circle &amp;c,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">    polygon ret;</span><br><span class="line">    point a=l.s,b=l.t;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x)&#123;</span><br><span class="line">        <span class="type">double</span> d=<span class="built_in">fabs</span>(c.cn.x-a.x);</span><br><span class="line">        <span class="keyword">if</span>(d&lt;c.r)&#123;</span><br><span class="line">            <span class="type">double</span> dy=<span class="built_in">sqrt</span>(c.r*c.r-d*d);</span><br><span class="line">            point p1=&#123;a.x,c.cn.y+dy&#125;;</span><br><span class="line">            point p2=&#123;a.x,c.cn.y-dy&#125;;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p1,l))ret.<span class="built_in">push_back</span>(p1);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p2,l))ret.<span class="built_in">push_back</span>(p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">double</span> k=(b.y-a.y)/(b.x-a.x);</span><br><span class="line">        <span class="type">double</span> bb=a.y-k*a.x;</span><br><span class="line">        <span class="type">double</span> x0=c.cn.x;</span><br><span class="line">        <span class="type">double</span> y0=c.cn.y;</span><br><span class="line">        <span class="type">double</span> A=k*k+<span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> B=<span class="number">2</span>*(k*(bb-y0)-x0);</span><br><span class="line">        <span class="type">double</span> C=x0*x0+(bb-y0)*(bb-y0)-c.r*c.r;</span><br><span class="line">        <span class="type">double</span> delta=B*B<span class="number">-4</span>*A*C;</span><br><span class="line">        <span class="keyword">if</span>(delta&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> t1=(-B+<span class="built_in">sqrt</span>(delta))/<span class="number">2</span>/A;</span><br><span class="line">            <span class="type">double</span> t2=(-B-<span class="built_in">sqrt</span>(delta))/<span class="number">2</span>/A;</span><br><span class="line">            point p1=&#123;t1,k*t1+bb&#125;;</span><br><span class="line">            point p2=&#123;t2,k*t2+bb&#125;;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p1,l))ret.<span class="built_in">push_back</span>(p1);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p2,l))ret.<span class="built_in">push_back</span>(p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文中<code>polygon</code>就是<code>vector&lt;point&gt;</code>，该定义会在第四节中给出。方便起见，相切情况，我们默认产生了两个重合的交点，这样可以避免一些容易产生精度误差的讨论。</p>
<h4 id="3-4-2-点向式解法"><a href="#3-4-2-点向式解法" class="headerlink" title="3.4.2 点向式解法"></a>3.4.2 点向式解法</h4><p>设线段一个端点为 $A(x_a,y_a)$ ，到另一个端点的向量 $\vec{AB}(dx,dy)$，得到向量式 $$P(x_a+t<em>dx,y_a+t</em>dy)\in Circle$$</p>
<p>带入圆方程 $(x-x_0)^2+(y-y_0)^2&#x3D;r^2$ 可以得到一个形如 $At^2Bt+C&#x3D;0$ 的一元二次方程，有<br>$$A&#x3D;dx^2+dy^2$$</p>
<p>$$B&#x3D;2*(dx*(x_a-x_0)+dy*(y_a-y_0))$$</p>
<p>$$C&#x3D;(x_a-x_0)^2+(y_a-y_0)^2-r^2$$</p>
<p>直接求解即可。</p>
<h2 id="4-简单多边形"><a href="#4-简单多边形" class="headerlink" title="4 简单多边形"></a>4 简单多边形</h2><p>任何一个简单多边形都可以被认为是一连串点分别连向他们的前驱和后继，所以在存储时，我们只要存储一个有序的点的序列即可。需要说明的是，因为简单，所以要保证没有任何两条线段相交。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;point&gt; polygon;</span><br></pre></td></tr></table></figure>

<p>此外，我们默认头节点和尾节点在多边形存储中是同一节点，因为凸包自成环，不存在逻辑意义上的首尾，所以经常要另行处理头节点和尾节点，方便起见将其存储在两端，就可以避免许多讨论。</p>
<h3 id="4-1-凸包"><a href="#4-1-凸包" class="headerlink" title="4.1 凸包"></a>4.1 凸包</h3><p>凸包是绝大多是计算几何问题的核心，在没有圆的情况下尤其如此。对二维凸包的一个感性认识是：在一个平面上有一堆钉子，用一个橡皮筋把他们套起来，橡皮筋的形状结就是这些点构成的凸包。</p>
<p>对于凸包更深入的了解建议进一步观看邓俊辉老师的《计算几何》课程凸包章节，在课程中对凸包能够处理的绝大多数问题都进行了解答和证明。在本文中，本文只会提供一些粗浅的结论，方便读者快速掌握所需知识。</p>
<p>需要说明的是，求凸包的理论下界是 $O(log_2n)$ 的，可以规约到排序问题来证明。对于任意一个排序问题，可以将他们的值在线性时间内映射到二维空间中的一根辅助线(如抛物线)上，调用凸包算法，并且在线性时间内遍历输出得到排序结果。如此就通过规约方法证明了凸包求解算法的理论复杂度下界。</p>
<h4 id="4-1-1-判断点在凸包内"><a href="#4-1-1-判断点在凸包内" class="headerlink" title="4.1.1 判断点在凸包内"></a>4.1.1 判断点在凸包内</h4><p>要求凸包，其实就是要把所有在凸包内的点删去，所以先观察凸包内点的性质。</p>
<p>凸包有如下性质：凸包内所有点都在凸包上有向线段的同一侧。用叉积的说法来说，叉出来的结果正负性是一致的。这点不难从观察中发现。于是我们定义<code>toLeft</code>测试，判断点和有向线段的位置关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isToLeft</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">det</span>(l.s,l.t,o)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值为<code>1</code>说明点在有向线段左侧。如果对所有凸包上所有线段返回值都一致，那么说明点在凸包内。因为不知道凸包旋转方向，所以要做两轮测试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPointInConvexHull</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> polygon &amp;p)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isToLeft</span>(o,(segment)(p[i],p[i+<span class="number">1</span>])))tmp=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span> tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isToLeft</span>(o,(segment)(p[i+<span class="number">1</span>],p[i])))tmp=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要允许点在凸包上，将<code>toLeft</code>测试中<code>&gt;</code>替换为<code>&gt;=</code>即可。</p>
<h4 id="4-1-2-求凸包"><a href="#4-1-2-求凸包" class="headerlink" title="4.1.2 求凸包"></a>4.1.2 求凸包</h4><p>从上一节中，得到一个点在凸包内部的充要条件。现在我们讨论，如何求解凸包。假设已知一条有向边，那么考虑这条有向两侧的点，显然如果两侧都有点，那么这条边必定不在凸包上；反之必定在凸包上。如果能将所有点的角度排序，就可以在线性时间内得到凸壳。排序法+单调栈的凸包算法就是基于该原理，将所有点按照某种顺序排序，然后根据旋转角来决定进栈出栈，算法完成时即得到最终结果。而旋转角可以通过叉积来代替，以避免弱智的三角函数操作。</p>
<p>常见的排序法有graham法和andrew法，他们分别通过极角排序和水平序排序来实现。</p>
<p>Graham先选取一个在凸包上的枢轴点(如横坐标最小的点)，按照极角排序，然后单调栈跑一圈即可。<br><img src="https://img-blog.csdnimg.cn/20200508120139593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图4.1.2.1"><br>Andrew则是按照水平序排序，然后分上下凸壳跑两次单调栈。两种做法其实并没有太大区别，但是个人比较喜欢水平序排序，因为看起来比较优美（因为不需要另外找一个枢轴点，排水平序的时候自然产生了）。事实上，两者的原理是完全一样的，水平序可以认为是关于一个无穷高的点的极角序。<br><img src="https://img-blog.csdnimg.cn/20200508120656917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.1.2.2"></p>
<p>此处只给出水平序的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">polygon <span class="title">convexHull</span><span class="params">(polygon p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    polygon ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">det</span>(*ret.<span class="built_in">rbegin</span>(),*++ret.<span class="built_in">rbegin</span>(),p[i])&lt;=<span class="number">0</span>)ret.<span class="built_in">pop_back</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=ret.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p.<span class="built_in">size</span>()<span class="number">-2</span>;~i;--i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()&gt;m&amp;&amp;<span class="built_in">det</span>(*ret.<span class="built_in">rbegin</span>(),*++ret.<span class="built_in">rbegin</span>(),p[i])&lt;=<span class="number">0</span>)ret.<span class="built_in">pop_back</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此段代码中求出凸包，初始点会在末尾位置出现</span></span><br><span class="line">    <span class="comment">// ret.pop_back();</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要求三点共线的情况下，在凸包上点的个数，则将<code>det</code>后面的比较操作符进行修改即可。</p>
<h4 id="4-1-3-旋转卡壳"><a href="#4-1-3-旋转卡壳" class="headerlink" title="4.1.3 旋转卡壳"></a>4.1.3 旋转卡壳</h4><p>众所周知旋转卡壳有16种读法。但是其用法相对单一：在 $O(n)$ 时间内计算给定凸上的所有对踵点。感性认识对踵点，就是从某个点出发，能走到的最远点，这两个点构成一组对踵点。更科学的表述是，如果能用一组平行线将凸包包裹，那么在平行线上的点对都是对踵点。在凸包上，该关系具有对称性。</p>
<p>从平行线的定义不难看出，该算法可以在 $O(n)$ 时间内快速求出凸包最远点对&#x2F;最远点线距。</p>
<p>不难发现，对于一个点而言，所有有序的其他点和他的距离是一个单峰函数，一次查询可以使用三分法实现。对于全部点对，则可以采用双指针法，这就是旋转卡壳的基本思想。</p>
<p>以下给出一个最远点线距的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">rotateCalipers</span><span class="params">(polygon P)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">1e15</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p]))&lt;<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p+<span class="number">1</span>])))&#123;</span><br><span class="line">            ++p;</span><br><span class="line">            p%=P.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p]));</span><br><span class="line">        tmp/=<span class="built_in">dis</span>(P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">        ret=<span class="built_in">min</span>(tmp,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要计算对踵点或者最远点对的话，只要修改<code>while</code>内的比较函数为点和点之间的距离即可。</p>
<h3 id="4-2-三角剖分"><a href="#4-2-三角剖分" class="headerlink" title="4.2 三角剖分"></a>4.2 三角剖分</h3><p>当所求与面积有关时，可以用带正负面积的三角剖分来实现问题的简化。任意选取一点作为基点 $o$，和简单多边形上有向相邻的两点 $p_i,p_{i+1}$ 组成三角形，根据叉积 $det(o,p_i,p_{i+1})$ 判断正负性即可。</p>
<h4 id="4-2-1-面积"><a href="#4-2-1-面积" class="headerlink" title="4.2.1 面积"></a>4.2.1 面积</h4><p>求简单多边形面积只要直接暴力模拟上述过程求解即可。枢轴点可以直接选取原点，注意点类要设置为<code>double</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> point o=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfPolygon</span><span class="params">(<span class="type">const</span> polygon &amp;P)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        ret+=<span class="built_in">det</span>(o,P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ret/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-重心"><a href="#4-2-2-重心" class="headerlink" title="4.2.2 重心"></a>4.2.2 重心</h4><p>简单多边形的重心不易求解，但是三角形重心就是三点坐标均值。进行三角剖分后，对各三角形按照面积求加权平均值即可得到简单多边形重心。枢轴点也可以直接选取原点，注意点类要设置为<code>double</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> point o=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="function">point <span class="title">centroidOfPolygon</span><span class="params">(<span class="type">const</span> polygon &amp;P)</span></span>&#123;</span><br><span class="line">    point ret=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">det</span>(o,P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">        ret=ret+(point)&#123;(P[i].x+P[i+<span class="number">1</span>].x)*tmp,(P[i].y+P[i+<span class="number">1</span>].y)*tmp&#125;;</span><br><span class="line">        sum+=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;ret.x/sum/<span class="number">3</span>,ret.y/sum/<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-与圆面积交"><a href="#4-2-3-与圆面积交" class="headerlink" title="4.2.3 与圆面积交"></a>4.2.3 与圆面积交</h4><p>选取圆心为枢轴点进行三角剖分后，可以计算一点在圆心的三角形和原的面积交。接下来只要进行分类讨论即可。</p>
<p>可以简单分为四类：全在里面，一个角在外面，全在外面(不相交，相交)。对于全在外面且相切的情况吗其实和不相交的结果一致，所以可以直接忽略，视为不相交即可。<br><img src="https://img-blog.csdnimg.cn/20200508123202396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.2.3.1"><br>我们采用的处理手段是把他们分解成扇形和三角形进行处理。<br><img src="https://img-blog.csdnimg.cn/20200508123238601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.2.3.2"><br>如此便是一堆大讨论的操作。</p>
<p>看起来很复杂的讨论，其实在实现的时候可以通过一些技术手段来规避多数的讨论，从而降低编程的负担。</p>
<p>作者采用的方案是：对两点排序，将离圆心近的视为内点，另一个视为外点。再判断交点个数，如果没有交点，那么要么全内，要么全外，判断任意一点位置即可；如果有一个交点，那么一定是内点到交点为三角，交点到外点为扇面；如果有两个交点，那么一定是两侧扇面，中间三角，即两个交点构成三角，对于原线段上每一个点，找两个交点中较近的一个，构成扇面（如果将相切视为一种情况，则讨论会复杂很多）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfCircleIntersectSegment</span><span class="params">(<span class="type">const</span> circle &amp;c,point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dis</span>(c.cn,a)&gt;<span class="built_in">dis</span>(c.cn,b))<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dis</span>(c.cn,b)&lt;=c.r)&#123;</span><br><span class="line">        ret=<span class="built_in">areaOfTriangle</span>(c.cn,a,b);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        polygon p=<span class="built_in">circleIntersectSegment</span>(c,a,b);</span><br><span class="line">        <span class="keyword">switch</span> (p.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ret=<span class="built_in">areaOfSector</span>(c,a,b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ret=<span class="built_in">areaOfTriangle</span>(c.cn,a,p[<span class="number">0</span>])+<span class="built_in">areaOfSector</span>(c,p[<span class="number">0</span>],b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dis</span>(p[<span class="number">0</span>],a)&gt;<span class="built_in">dis</span>(p[<span class="number">1</span>],a))<span class="built_in">swap</span>(p[<span class="number">0</span>],p[<span class="number">1</span>]);</span><br><span class="line">            ret=<span class="built_in">areaOfTriangle</span>(c.cn,p[<span class="number">0</span>],p[<span class="number">1</span>])+<span class="built_in">areaOfSector</span>(c,a,p[<span class="number">0</span>])+<span class="built_in">areaOfSector</span>(c,b,p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>areaOfTriangle</code>，<code>areaOfSector</code>，<code>circleIntersectSegment</code>，<code>dis</code>均为上文提及前置函数。</p>
<h2 id="5-数值计算"><a href="#5-数值计算" class="headerlink" title="5 数值计算"></a>5 数值计算</h2><p>众所周知，数形结合是解决几何问题的一大法宝。当遇到一坨扭曲的丑陋的图形的时候，解析计算实在太费事了，这个时候数值计算就可以充分利用计算机的算力优势，来暴力解决本该积分&#x2F;解方程解决的问题。</p>
<h3 id="5-1-插值法"><a href="#5-1-插值法" class="headerlink" title="5.1 插值法"></a>5.1 插值法</h3><p>插值法解决这样一类问题：给定一系列的二维离散点，再未定义的位置补差连续函数，使得其通过所有给定离散点。换言之，建立一条关于给定点的拟合函数。</p>
<p>以下介绍的拉格朗日插值和牛顿插值都属于代数插值，在不考虑精度的情况下得到的结果是一致的。因为 $n$ 个点构造的一元 $n-1$ 次方程是唯一的。用待定系数法，列方程，克拉默法则求解易证结果的唯一性。</p>
<h4 id="5-1-1-拉格朗日插值"><a href="#5-1-1-拉格朗日插值" class="headerlink" title="5.1.1 拉格朗日插值"></a>5.1.1 拉格朗日插值</h4><p>拉格朗日插值的核心思想是，对于 $n$ 个点，构造一个 $n$  项的多项式，当 $x&#x3D;x_i$ 时，使第 $i$ 项为 <code>1</code>；当 $x\not&#x3D;x_i$ 时，使第 $i$ 项为 <code>0</code>。</p>
<p>对于给定的 $n$ 个点 $(x_0,y_0),(x_1,y_1)\dots(x_{n-1},y_{n-1})$，可以构造如下插值多项式</p>
<p>$$P(x)&#x3D;\sum_{i&lt;n}\prod_{i\not&#x3D;j,j&lt;n}\frac{x-x_j}{x_i-x_j}y_i$$</p>
<p>举个例子，如果有两项，那么插值多项式为</p>
<p>$$f(x)&#x3D;\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1$$</p>
<p>如此达到了离线的 $O(n^2)$ 复杂度的单次构造，查询。</p>
<h4 id="5-1-2-牛顿插值"><a href="#5-1-2-牛顿插值" class="headerlink" title="5.1.2 牛顿插值"></a>5.1.2 牛顿插值</h4><p>拉格朗日插值主要的劣势在于，当插入一个新点时，整个函数需要重新进行计算，影响程序性能；进行了大量的除法运算，引入了浮点误差。</p>
<p>牛顿插值法在逻辑上可以得到和拉格朗日插值法一样的结果，但是在精度上更有优势，并且有着更强的拓展性。</p>
<p>要介绍牛顿插值法的基本原理，要先从低维情形说起，当只有一个点 $(x_0,y_0)$ 时，直接构造<br>$$f_0(x)&#x3D;y_0$$<br>函数总是通过这个点。</p>
<p>接下来加入一个点 $(x_1,y_1)$，我们希望不影响之前经过的点，并且在此基础上经过新点，于是构造一个 $b_1(x-x_0)$ 的累加项使得新函数不影响函数在 $x&#x3D;x_0$ 处的函数值，即<br>$$f_1(x)&#x3D;f_0(x)+b_1(x-x_0)$$<br>代入 $(x_1,y_1)$ 可以求出 $b_1$，从而也能通到新点上。</p>
<p>再加入点 $(x_2,y_2)$，类似地，构造<br>$$f_2(x)&#x3D;f_1(x)+b_2(x-x_0)(x-x_1)$$<br>解出 $b_2$ 即可。迭代展开即可得到牛顿插值多项式，当插入新点时，按照上述操作继续拓展即可，每次解 $b$ 都是求一个一元一次函数的过程。</p>
<p>更一般地表述是，令<br>$$\phi_i(x)&#x3D;\prod_{j&lt;i}(x-x_j)$$<br>有牛顿插值多项式<br>$$f(x)&#x3D;\sum_{i&lt;n}b_i\phi_i(x)$$</p>
<p>一般牛顿迭代法使用差商的方式实现。定义差商<br>$$f[x_{n-1},x_{n-2}\cdots x_0]&#x3D;\frac{f[x_{n-1}\cdots x_1]-f[x_{n-2}\cdots x_0]}{x_{n-1}-x_0}$$</p>
<p>且<br>$$f[x_i]&#x3D;f(x_i)$$</p>
<p>经过一通乱算(这里相关证明可以自行查询相关文献，如《自然哲学的数学原理》)，可以发现<br>$$f[x_{n},x_{n-1}\cdots x_0]&#x3D;b_n$$</p>
<p>则有牛顿插值多项式最终表达式<br>$$f(x) &#x3D;  f[x_0]+f<a href="x-x_0">x_1,x_0</a>+\dots+f<a href="x-x_%7Bn-2%7D">x_{n-1},x_{n-2}\dots x_0</a>\cdots(x-x_0)$$</p>
<p>在计算时，用二维数组记录各次差商即可，最终得到的三角矩阵最下一排即是上述系数。可以在 $O(n^2)$ 时间内在线计算，求解。</p>
<h4 id="5-1-3-分段线性插值"><a href="#5-1-3-分段线性插值" class="headerlink" title="5.1.3 分段线性插值"></a>5.1.3 分段线性插值</h4><p>分段线性插值是一种比较朴素的插值方案，即对每个横坐标相邻的两点见连线得到一条过所有所求点的折线。但是这种做法得到的函数不连续，且因为形式过于简单，拟合效果无法得到保证。</p>
<h3 id="5-2-数值积分"><a href="#5-2-数值积分" class="headerlink" title="5.2 数值积分"></a>5.2 数值积分</h3><p>数值积分用来通过暴力手段计算积分。如果一个积分可以通过计算得到，那么就不需要暴力，这里我们讨论的都是难以(或者懒得)通过计算积分得到的情况。</p>
<p>一个比较简单的策略是取一些等距的点，使用上一节中介绍的插值法构造拟合函数，然后对构造出来的函数积分。因为保证是一元高次多项式，所以积分相对容易且可积。但是在高次情形下该方法有着较大的局限性。</p>
<p>另一种数值积分的方案是使用定积分的定义，分割成条，对每个长条用梯形面积公式计算(类似分段线性插值后分段积分)。但是当遇到一些不那么友好的函数时，这种做法很容易发生精度爆炸的惨案。</p>
<h4 id="5-2-1-牛顿-柯斯特公式"><a href="#5-2-1-牛顿-柯斯特公式" class="headerlink" title="5.2.1 牛顿-柯斯特公式"></a>5.2.1 牛顿-柯斯特公式</h4><p>牛顿-柯斯特公式对于上述切条分别求面积再求和的算法的拓展。若要对区间 $I&#x3D;[a,b]$ 积分，先对其进行等分，得到 $x_k&#x3D;a+k·\frac{b-a}{n} (k&#x3D;0,1,\cdots,n)$ ，求各个数值 $f(x_i)$，对这 $n+1$ 个点进行拉格朗日插值，然后再对得到的 $n$ 次多项式积分。</p>
<p>令步长 $h&#x3D;\frac{b-a}{n}$，有<code>Cotes</code>系数 $C_k^{(n)}$ 满足<br>$$C_k^{(n)}&#x3D;\frac{h}{b-a}\int_0^n\prod_{j\leq n,j\not&#x3D;k}\frac{t-j}{k-j}\text{d}t&#x3D;\frac{(-1)^{n-k}}{nk!(n-k)!}\int_0^n\prod_{j\leq n,j\not&#x3D;k}(t-j)\text{d}t$$ </p>
<p>且有数值积分公式<br>$$\int_a^bf(x) \approx(b-a)\sum_{k&#x3D;0}^nC_k^{(n)}f(x_k)$$</p>
<p>当取 $n&#x3D;1$ 时(也就是将积分区间切成一块)，可以得到朴素的梯形公式<br>$$C_0^{(1)}&#x3D;C_1^{(1)}&#x3D;\frac{1}{2}$$</p>
<p>$$\int_a^bf(x) \approx\frac{b-a}{2}[f(a)+f(b)]$$</p>
<h4 id="5-2-2-辛普森积分"><a href="#5-2-2-辛普森积分" class="headerlink" title="5.2.2 辛普森积分"></a>5.2.2 辛普森积分</h4><p>当 $n&#x3D;2$ 时(切成两块)，可以得到辛普森积分公式。<br>$$C_0^{(2)}&#x3D;C_2^{(2)}&#x3D;\frac{1}{6}\ ,\ C_1^{(2)}&#x3D;\frac{4}{6}$$</p>
<p>$$\int_a^bf(x) \approx\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]$$</p>
<h4 id="5-2-3-自适应辛普森积分"><a href="#5-2-3-自适应辛普森积分" class="headerlink" title="5.2.3 自适应辛普森积分"></a>5.2.3 自适应辛普森积分</h4><p>辛普森积分是最常用的数值积分公式，他只比梯形公式多了一项，却把代数精度提高到了3，可以精确拟合三次及以下的函数。但是如果被积函数只有三次，大可以直接手算积分，当遇到更高次甚至是非多项式函数时，我们需要更加有力的武器。</p>
<p>根据类似积分定义的思路，如果我们将原函数分割的越细密，精度自然就越高。自适应辛普森积分通过对原问题进行分治来取得更高的精度：如果一个辛普森积分精度不够，那就两个。</p>
<p>不妨设被积函数 $f(x)$ ，要对区间 $I&#x3D;[a,b]$ 积分。则有朴素辛普森公式：<br>$$F(a,b)\approx\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]$$</p>
<p>令中点 $m&#x3D;\frac{a+b}{2}$ ，如果发现分治进行数值积分的结果和直接数值积分的结果之差小于所需精度，即<br>$$|F(a,b)-F(a,m)-F(m,b)|\leq eps$$<br> 那么直接返回当前结果，否则分治处理两个子问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>-x+x*x-x*x*x*x+x*x*x*x*x;<span class="comment">//any arbitrary function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">F</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">f</span>(a)+<span class="number">4</span>*<span class="built_in">f</span>((a+b)/<span class="number">2</span>)+<span class="built_in">f</span>(b))/<span class="number">6</span>*(b-a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">simpson</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> eps)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> m=(a+b)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">double</span> s=<span class="built_in">F</span>(a,b),l=<span class="built_in">F</span>(a,m),r=<span class="built_in">F</span>(m,b);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(s-a-l)&lt;eps)<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">simpson</span>(a,m,eps)+<span class="built_in">simpson</span>(m,b,eps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6 结语"></a>6 结语</h2><p>本文主要介绍了关于计算几何的一些基本知识和思想，并以此为基础简单介绍一些算法。本文的点，向量，圆部分的模板部分借鉴了上交俞勇老师主编的《ACM国际大学生程序设计竞赛算法与实践》，一些计算几何相关但是不太常用的算法，诸如求多边形的核等算法，本文并未涉及，感兴趣的读者可以自行查阅。在凸包部分的证明，作者主要参考了邓俊辉老师的《计算几何》。本文最后数值计算部分则主要从《数值计算》和部分博客中归纳总结而来，因为有些内容年代比较久远，故无法确定来源，如有兴趣可自行查找相关资料。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Yifan
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/" title="计算几何总结">http://example.com/2022/09/04/计算几何总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/04/%E4%B8%89%E8%A7%92%E5%BD%A2%E5%A4%96%E5%BF%83%E8%AE%A1%E7%AE%97/" rel="prev" title="三角形外心计算">
      <i class="fa fa-chevron-left"></i> 三角形外心计算
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
