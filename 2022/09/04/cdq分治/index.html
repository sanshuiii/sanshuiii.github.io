<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="问题引入陌上花开1若干个元素有三个属性$a,b,c$，问多少对数对$（i,j）$满足 $$a_i\leq a_j  , b_i\leq b_j , c_i\leq c_j$$ 分析如此类问题可以视为一个多维偏序问题，偏序即满足自反性，反对称性，传递性。画成拓扑图则可被视为一张DAG。 考虑这个问题的简单版本，如果只有一个属性，可以容易得到；如果有两个属性，常见的解决方案是对其中一维排序后，树状数组">
<meta property="og:type" content="article">
<meta property="og:title" content="cdq分治">
<meta property="og:url" content="http://example.com/2022/09/04/cdq%E5%88%86%E6%B2%BB/index.html">
<meta property="og:site_name" content="Sanshuiii">
<meta property="og:description" content="问题引入陌上花开1若干个元素有三个属性$a,b,c$，问多少对数对$（i,j）$满足 $$a_i\leq a_j  , b_i\leq b_j , c_i\leq c_j$$ 分析如此类问题可以视为一个多维偏序问题，偏序即满足自反性，反对称性，传递性。画成拓扑图则可被视为一张DAG。 考虑这个问题的简单版本，如果只有一个属性，可以容易得到；如果有两个属性，常见的解决方案是对其中一维排序后，树状数组">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020032217554238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200322175906792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200322180429916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2022-09-04T12:07:16.000Z">
<meta property="article:modified_time" content="2022-09-04T12:23:30.337Z">
<meta property="article:author" content="Yifan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2020032217554238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="http://example.com/2022/09/04/cdq%E5%88%86%E6%B2%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>cdq分治 | Sanshuiii</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sanshuiii</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/cdq%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cdq分治
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:07:16 / Modified: 16:23:30" itemprop="dateCreated datePublished" datetime="2022-09-04T16:07:16+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><h2 id="陌上花开1"><a href="#陌上花开1" class="headerlink" title="陌上花开1"></a>陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a></h2><p>若干个元素有三个属性$a,b,c$，问多少对数对$（i,j）$满足 $$a_i\leq a_j  , b_i\leq b_j , c_i\leq c_j$$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如此类问题可以视为一个多维偏序问题，偏序即满足自反性，反对称性，传递性。画成拓扑图则可被视为一张DAG。</p>
<p>考虑这个问题的简单版本，如果只有一个属性，可以容易得到；如果有两个属性，常见的解决方案是对其中一维排序后，树状数组维护前缀，按照某一位以每个元素log的复杂度顺序处理。</p>
<p>在维度更高的情况下，cdq分治是简化问题的一个有效手段。</p>
<p>cdq分治的核心思想即以一个log为代价，降低此类多维偏序一个维度。</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="偏序和全序"><a href="#偏序和全序" class="headerlink" title="偏序和全序"></a>偏序和全序</h2><p>偏序即满足：自反性，反对称性，传递性的二元关系。<br>全序即满足：完全性，反对称性，传递性的二元关系。<br>两者唯一的区别是第一个性质，但是不难发现，自反性即 $$\forall x\ \ s.t. \ \ xRx$$<br>完全性即  $$\forall x,y\ \ s.t. \ \ xRy$$<br>即偏序只要自己和自己可比即可，全序则是集合内任意两个元素可比。</p>
<p>像我们处理了如例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>的多属性比较关系，往往是偏序的，因为可能出现 $a_i&gt;b_j,b_i&lt;b_j$的情况，两者不可比。而自然数集上的大小关系往往可以被视为全序关系，因为任意两个自然数都可比。</p>
<p>引申一点，在全序关系上我们引入良序的定义：若一个全序集上任意一个非空子集S都有最小元，则称其为良序。</p>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>求逆序对个数事实上可以被视为一个二位偏序的统计问题。对于序列A上每一个元素 $a_i$都有两个属性，位置 $i$ 和大小$a_i$，把他们全部揪出来可以形成一个偏序集。那么逆序对实质就是要求集合内所有满足如下关系的对$（i，j）$的数量: $$i&lt;j\ ,\ a_i&gt;a_j$$ 也即可比的元素对个数。</p>
<p>两种常见的计算方案如下: 从后往前求维护树状数组求解<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=cdd1a6a4001410d3&rsv_t=68e5dK04hafZNVfCEixDIGedJhu5slXuzXdebsbxpjYiyVYXZoZCKqjWA7w&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=27&rsv_sug1=19&rsv_sug7=100&rsv_sug2=0&inputT=2463&rsv_sug4=2463&rsv_sug=1">2</a>，或者归并排序<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=8b7275410009bcb5&rsv_t=3625sKfYylft69ydnnJ5hh5Z02yhYhUuwnPy22t75oasH4840S/moox+1ks&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=26&rsv_sug1=21&rsv_sug7=100&rsv_sug2=0&inputT=3529&rsv_sug4=3529">3</a>。</p>
<p>后面我们会讲到，归并排序实质上就是cdq分治在二维偏序上的一种应用。而在更高维的三位偏序上，常常采用cdq分治+树状数组的解法。</p>
<h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><p>在这里我们忽略一维情形，因为cdq分治的思想就是降维，一维无维可降故忽略。</p>
<h2 id="二维偏序计数"><a href="#二维偏序计数" class="headerlink" title="二维偏序计数"></a>二维偏序计数</h2><p>以逆序对问题为例，假定这里读者已经完全掌握了归并排序求逆序对<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=8b7275410009bcb5&rsv_t=3625sKfYylft69ydnnJ5hh5Z02yhYhUuwnPy22t75oasH4840S/moox+1ks&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=26&rsv_sug1=21&rsv_sug7=100&rsv_sug2=0&inputT=3529&rsv_sug4=3529">3</a>的算法，我们将在此基础上展开讨论。</p>
<h3 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h3><p>要统计数对个数，一种不重复不遗漏的方案是穷举数对中的一个元素，判断另一个元素有几种合法。我们不妨假设要统计数对 $(i,j)$ 的个数，那么对于元素 $j$ ，我们要找出所有和他可比的元素。</p>
<blockquote>
<p>在这里要特别明确一点，本问题中讨论的偏序，指的是各个元素分别满足某种全序关系(在只出现的元素集上满足良序关系)的偏序。比如例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>中，各个属性都是正整数，各个属性内部为全序，可排序。</p>
</blockquote>
<p>那么 $j$ 已经确定，我们归并排序对问题进行分治，那么这个 $i$ 要么和 $j$ 分在同一组中，要么分在另一组中。在常见的分治问题中，往往只需要处理分在同一种中的情况，cdq分治的特性就是将跨组的影响也计算出来，从而将分治的思想引入到偏序计数的问题中。</p>
<p>此时我们在用数据结构保存偏序集中每个元素时，除了要保存元素本身的属性外，还要保存和该元素有关的有序对的数量。在完成算法后，将他们全部取出来求和就是总对数。</p>
<h3 id="以逆序对问题为例"><a href="#以逆序对问题为例" class="headerlink" title="以逆序对问题为例"></a>以逆序对问题为例</h3><p>我们把整个逆序对的元素抽出来，得到一个二维的偏序集，在几何上可以表示为平面上的一堆点。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032217554238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="二维偏序"><br>此时我们使用分治思想，把他们从中间切开，得到左右两部分，如棕色图所示，可以递归处理。我们不妨假设我们此时考虑某个元素 $j&#x3D;5$ ，那么我们实质上要考虑的是有多少 $i$ 满足 $i&lt;j$ 且 $a_i&gt;a_j$。肉眼观察可得有两个，分别是 $i&#x3D;2$ 和 $i&#x3D;4$。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322175906792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 $i&#x3D;4$ 的贡献在分治处理右半边的时候可以得到，所有放心递归即可。而 $i&#x3D;3$ 的贡献还在左半侧，所以需要单独处理。如何处理呢？cdq分治在这里采用的策略就是先排序，后归并。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322180429916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在两侧分别对元素值排序后，实质上我们要统计跨界贡献的就是粉色区域内元素的个数。这个可以很容易在归并排序时做到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            <span class="built_in">add</span>(a[i].z);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个过程中，因为在当前排序的这一元素上是全序的，所以可以排序后归并遍历快速得到结果。我们会发现cdq分治带来了两个log，在分治时带来一个log，在统计跨界元素个数时因为要排序又带来一个log。但是因为这两个log时平行的，所以只需要一个log。而在归并排序求逆序对个数这一特殊问题时，因为归并排序本身可以得到子问题的有序形式，所以在实际操作的时候可以免去排序这一步。但是在cdq分治这一算法框架中排序这一步是必要的。在文章最后总结时我还会给出一个完整的框架，但是到目前为止我们应该已经初窥了cdq分治的奇妙而精巧的转化思想。</p>
<h3 id="更暴力的解法"><a href="#更暴力的解法" class="headerlink" title="更暴力的解法"></a>更暴力的解法</h3><p>不难发现其实本问题可以转化为一个平面上若干个区域内点计数的问题。一个更加暴力的做法是二维线段树或者树套树维护区间和，暴力查询即可，复杂度$O(n log n log n)$</p>
<h2 id="三维偏序计数"><a href="#三维偏序计数" class="headerlink" title="三维偏序计数"></a>三维偏序计数</h2><p>本部分内容以例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>为例。</p>
<h3 id="问题建模-1"><a href="#问题建模-1" class="headerlink" title="问题建模"></a>问题建模</h3><p>先考虑我们的老朋友数形结合，不难发现三位偏序可以把他看成一个立体空间里点计数的问题。暴力做法不难想到，可以三维8叉树暴力求解，或者树套树套树把低维数据结构套成高维的。编程复杂度巨大，显然超出一个智力中等水平的大学生的能力范围。</p>
<p>但是因为我们有了cdq分治这一有利武器，我们可以考虑将问题降维。我们对数组进行如下三步操作：</p>
<p>Step1：按某一维排序<br>Step2：分治解决子问题<br>Step3：解决跨界问题，累计贡献</p>
<p>这也是cdq分治的基本框架。我们可以看到，在离线处理答案的时候，是以贡献累计的方式累加到答案上去的，所以这对问题有一个要求：可独立的叠加和累计。不难发现，计数问题是满足这个条件的，在每个点之间可以互相独立的累计到一起。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>首先按照a轴从小到大排序，这一就得到了一个类似于逆序对的形式：一维有序，另外两维度乱七八糟。现在我们考虑每一个元素作为右元形成的数对，显然只有他左边的点才可能产生贡献，如此我们我们只要统计两部分内容：和他分在一组的和在他左边组的。</p>
<p>和他一组的很好处理，直接递归求解即可。<br>和他不一组的则需要另行处理，这是整个cdq分治中最需要动脑子的部分。</p>
<p>那么怎么处理呢？一个平凡的想法是直接把左半部用二维线段树&#x2F;树套数维护，右半部分查询。或者各自排序再归并，这样保证第一维有序(因为跨过中线，所以就算重排之后a仍然有序)。并且归并第二维也有序，此时直接使用树状数组维护前缀即可。</p>
<p>此处给出例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>的AC代码，结合代码进一步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z,w,ans;</span><br><span class="line">&#125;a[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="type">int</span> n,k,nn;</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x&amp;&amp;a.y==b.y)<span class="keyword">return</span> a.z&lt;b.z;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x)<span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y==b.y?(a.z&lt;b.z):(a.y&lt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWT</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N=maxn&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;N)&#123;</span><br><span class="line">            a[x]+=d;</span><br><span class="line">            x+=x&amp;(-x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            res+=a[x];</span><br><span class="line">            x-=x&amp;(-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l,m);</span><br><span class="line">    <span class="built_in">cdq</span>(m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">sort</span>(a+l,a+m+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="built_in">sort</span>(a+m+<span class="number">1</span>,a+r+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            fwt.<span class="built_in">add</span>(a[i].z,a[i].w);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=fwt.<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;i;++j)fwt.<span class="built_in">add</span>(a[j].z,-a[j].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b,b+n,cmpx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,c=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ++c;</span><br><span class="line">        <span class="keyword">if</span>(b[i].x!=b[i+<span class="number">1</span>].x||b[i].y!=b[i+<span class="number">1</span>].y||b[i].z!=b[i+<span class="number">1</span>].z)&#123;</span><br><span class="line">            a[nn]=b[i];</span><br><span class="line">            a[nn].w=c;</span><br><span class="line">            ++nn;</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">0</span>,nn<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nn;++i)&#123;</span><br><span class="line">        ans[a[i].ans+a[i].w<span class="number">-1</span>]+=a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数内的内容是一些去重的预处理操作，注意cdq分治无法处理有重复元素的问题，原因是在进行不当的划分之后可能漏判一些情况。限于篇幅此处不表，读者可以自行在低维情况下手玩验证。在一般的套路中，其他的操作可视题目情况而定，但是对第一维排序必不可少即可，即Step1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b,b+n,cmpx);</span><br></pre></td></tr></table></figure>
<p>排序后，则可调用cdq分治，核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l,m);</span><br><span class="line">    <span class="built_in">cdq</span>(m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">sort</span>(a+l,a+m+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="built_in">sort</span>(a+m+<span class="number">1</span>,a+r+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            fwt.<span class="built_in">add</span>(a[i].z,a[i].w);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=fwt.<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;i;++j)fwt.<span class="built_in">add</span>(a[j].z,-a[j].w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，若某一时刻当前区间大小为1(代码中均采用闭区间)，那么该空间内部不会产生任何贡献，可以直接return，此为递归的终止边界。由此可见cdq分治是有穷的。</p>
<p>若区间大小不为1，那么必定可以得到两个子问题，直接分治解决即可，此为Step2。</p>
<p>其后则要对跨界内容进行处理，即Step3，首先分别排序，这样在归并时得到的序列在第二维上就是有序的了。此时我们要计算左半边对右半边的贡献，那么第一维度左边总是在右边的左边，分别排序后不会影响此性质，第一维度也相对有序。</p>
<p>这样看似是降低了两个维度，但是其实只降低了一个。我们考虑用树状数组求逆序对的过程，事实上我们是将下标视为时间维度，按照时间顺序维护树状数组和统计答案。对于其他任意的二维偏序问题，我们常见的处理方法是先对其中一维排序，视为时间序，再用树状数组等数据结构维护时间前缀上的信息。而在cdq分治中，我们在分治时保证第一维有序，分别排序保证第二维有序，于是我们按照第二维归并处理时，实质上是按照第二维时间序在操作。通过把点分为两部分，计算左边对右边的贡献，实质上我们在忽略第一维度的情况下得到了第二维的时间序，所以对原问题来说是降低了一个维度。</p>
<h1 id="cdq分治的极限"><a href="#cdq分治的极限" class="headerlink" title="cdq分治的极限"></a>cdq分治的极限</h1><p>各个属性分别满足全序关系的偏序二元对计数问题，我们上面对cdq分治使用的限制条件似乎太过于苛刻了，是否能够将其拓展，使得更多的问题可以由cdq分治解决呢？</p>
<p>答案是肯定的。不难发现，cdq分治是一种时间换维度的算法，而其中必须要满足全序关系的属性其实有且仅有Step1中被排序的一维。换一个角度看，其实cdq分治做的事情是：用一个log的复杂度，将原问题中的时间维消除，转化为一组元素对另一组元素的贡献计数问题。在此基础上，我们再进行归并排序，实质上是再构造一个时间维，而这并不是不可或缺的。</p>
<p>比如在陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>中，我们完全可以先使用cdq分治之后再对左半部分用二维线段树建树，再用右半部分的每个数对二位线段树逐个查询区间和累计答案。这样实质上我们做到了将8叉树(三维线段树)降维到了4叉树(二维线段树)。</p>
<p>而对于其他的问题，其实可以考虑很多种不同的算法和数据结构来维护跨区间的贡献，而他们很多是不要求满足偏序&#x2F;全序关系的，甚至不需要有“序”这个概念，比如有多少对gcd不为1之类。这和很多人提到的cdq分治是在“序”上乱搞的概念不太一样。cdq分治不在序上乱搞，而是消灭一组全序属性。</p>
<h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><h3 id="偏序-全序"><a href="#偏序-全序" class="headerlink" title="偏序+全序"></a>偏序+全序</h3><p>考虑如下问题，给出若干个元素，每个元素有属性a,b，问有多少对数对 $(i,j)$ 满足 $$a_i\leq a_j 且 b_i|b_j$$<br>其中 $x|y$ 表示 $x$ 是 $y$ 的因子。</p>
<p>解决方案比较容易想到，先按照a排序，然后cdq分治。接下来问题就变成如下问题：给定一个集合，里面若干个元素，每个元素有一个属性 $b$ , 若干次查询，问集合中有多少个数是查询数的因子。</p>
<p>暴力一点就左边维护一个hash，右边枚举因子。如果有现成的数据结构和算法也可以很轻松套上去。</p>
<h3 id="求和-全序"><a href="#求和-全序" class="headerlink" title="求和+全序"></a>求和+全序</h3><p>考虑如下问题，给出若干个元素，每个元素有属性a,b，问有多少对数对 $(i,j)$ 满足 $$a_i\leq a_j 且 b_i+b_j&#x3D;K$$</p>
<p>解决方案比较容易想到，先按照a排序，然后cdq分治。接下来问题就变成如下问题：给定一个集合，里面若干个元素，每个元素有一个属性 $b$ , 若干次查询，查询数为 $q$ ，问集合中有多少元素等于 $K-q$ 。</p>
<p>这样问题就变得非常简单，hash即可。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>根据上述两个随手捏的例题，不难得出使用cdq分治的情景：</p>
<ul>
<li>求解合法二元对个数(如果是更多元的话分治时需要更多分类讨论，并不实用，故此处认定只适合二元情形)</li>
<li>有至少一个属性的排序条件为全序关系，或者分段全序(只要满足能够分治且左右两边单向有序即可)</li>
<li>维度较高，简单的数据结构难以维护高维信息</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="cdq分治的思想"><a href="#cdq分治的思想" class="headerlink" title="cdq分治的思想"></a>cdq分治的思想</h2><p>把高维偏序问题降低一个维度，以一个log为代价。</p>
<h2 id="cdq分治的套路"><a href="#cdq分治的套路" class="headerlink" title="cdq分治的套路"></a>cdq分治的套路</h2><p>先对一个维度排序，接下来分治处理贡献：分治解决同块贡献；完事后因为第一维度在分治之后已经保证有序，接下来就变成在左边上统计右边的情况。如果是三维的，那么直接排序+归并即可再减掉一维，这一就减掉了两维，非常轻松的解决掉3维偏序的情况。如果是4维，可以无脑再套一个树套树。据说还可以cdq套cdq，但是目前还没有想明白怎么搞，先咕。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Yifan
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/09/04/cdq%E5%88%86%E6%B2%BB/" title="cdq分治">http://example.com/2022/09/04/cdq分治/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/04/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" rel="prev" title="快速傅里叶变换">
      <i class="fa fa-chevron-left"></i> 快速傅里叶变换
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/04/%E4%B8%89%E8%A7%92%E5%BD%A2%E5%A4%96%E5%BF%83%E8%AE%A1%E7%AE%97/" rel="next" title="三角形外心计算">
      三角形外心计算 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
