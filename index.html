<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="It was the best of times, it was the worst of times.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sanshuiii">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sanshuiii">
<meta property="og:description" content="It was the best of times, it was the worst of times.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yifan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sanshuiii</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sanshuiii</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">计算几何总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:34:48 / Modified: 16:35:20" itemprop="dateCreated datePublished" datetime="2022-09-04T16:34:48+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>计算几何计算机科学的一个重要分支，因此在算法竞赛中也是常考的一类题，难度从签到题到防AK题不等。本文是作者对计算几何在算法竞赛中的解题学应用的一点心得，主要介绍计算几何专题内比较经典的思想，算法和个人对此的一点心得。本文从逻辑上分为三个部分，第一部分是阐释解决有关计算几何算法问题时的设计思想，第二部分从点，向量，圆，三角，简单多边形等计算几何中主要处理的二维图像的角度出发，用面向对象的思想介绍类成员函数和成员变量（但是出于程序实现的方便，在设计程序时依然以面向过程为主），主要采用的手段仍然以解析几何为主。最后介绍非解析方法的数值计算技巧，用以解决一类其他的问题。本文将围绕问题转化，分类讨论等算法设计中常用的思想对上述内容进行阐释。</p>
<h3 id="1-1-精度"><a href="#1-1-精度" class="headerlink" title="1.1 精度"></a>1.1 精度</h3><p>在以解析几何为理论背景的计算几何问题中，精度对程序正确性的影响非常大，其中尤其以开根操作和三角函数操作影响恶劣。此外，受限于计算机存储空间有限性，在逻辑上无法直接存储无尽小数（不考虑分数类等间接表示的方法），所以在经过一系列操作后<code>==</code>操作符可能无法判断逻辑上等价而数值上不等价的表达式。</p>
<p>关于精度，主要就是要解决上述两个问题：精度降低和因此带来的等价判断处理。</p>
<p>第一个问题目前还没有很好的办法解决，在部分不需要非线性运算的问题中，可以用分数类来实现逻辑上的精确表述，在输出结果前不会产生精度损失。但是当遇到开根，三角函数等精度杀手时，分数类就显得力不从心了。一般而言，当精度要求为 $10^{-6}$ 时，可以容忍一次到二次开根操作或者一次(反)三角函数运算。使用<code>long double</code>可以略微提升精度，但是效果不明显。</p>
<p>在等价判断上，一般设一个所需精度级别的误差量，当两个数之差小于该误差量时，可以认为这两个数相等。因为这最多带来小于所需精度级别的误差，基本可以认为他是安全的。当该操作后还要套很多操作时，可以适当减小这个误差量。使用一个<code>cmp</code>函数来实现比较功能，返回值类似<code>java</code>中的 <code>compareTo</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> EPS=<span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;a,<span class="type">const</span> <span class="type">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;EPS)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个常用的手段是用<code>long long</code>存储数据。在处理不涉及距离，面积的问题时(或者只在最后一步求)，如凸包(只需要处理叉积)，可以判断性的操作都在整数范围下完成，只在计算距离面积数值时才转换为浮点型计算。这样可以有效避免各种浮点误差。</p>
<h3 id="1-2-剖分"><a href="#1-2-剖分" class="headerlink" title="1.2 剖分"></a>1.2 剖分</h3><p>在非算法竞赛中说的三角剖分，常指在一个简单多边形的顶点间连若干条互不相交的线段，将之分解成若干个三角形，从而对于多边形的面积，重心，面积交等问题时可以通过这些三角形间接求出来。这本质上是一种转换的思想，将不好处理的多边形，转换为熟悉的三角形，在三角形上进行分类讨论来解决各类实际问题。</p>
<p>但是这种做法在实现时非常复杂，先要用扫描线法进行单调多边形的划分，然后再在单调多边形上用扫描线法求出三角剖分，编程复杂度巨大。</p>
<p>考虑一个更加简便的做法，在求面积的情况下，本质上是对三角形面积的加和。当三角剖分没有相交时，出现的所有三角形都对结果贡献了正面积。在这里我们考虑负面积，对于一个枢轴点 $O$ , 有多边形 $P$ 面积为 $\sum_{i\in P}\vec{op_i}\times\vec{op_{i+1}}$ 。当叉乘结果为负时，则对结果贡献负面积，最终结果和不相交的三角剖分一致。这样，在处理和面积相关的问题时，对正负面积分别累计，就可以得到一个更加高效的三角剖分的解法。</p>
<h3 id="1-3-层次化设计"><a href="#1-3-层次化设计" class="headerlink" title="1.3 层次化设计"></a>1.3 层次化设计</h3><p>在设计程序时，建议对处理的对象进行逐级的定义和初始化，因为计算几何问题往往有着很强的层次性，如多边形在进行三角剖分后处理时，往往需要调用线段之间的操作，而此操作又依赖于点和向量的操作。从简单的几何结构及其操作开始定义，逐步搭建更高级的结构，可以有效降低编程过程中的复杂性。</p>
<h2 id="2-点，向量和线"><a href="#2-点，向量和线" class="headerlink" title="2 点，向量和线"></a>2 点，向量和线</h2><p>二维平面上的点和向量都可以用一个二元组来表示，事实上点坐标可以视为一个原点上引出的向量，所以可以将点和向量设计为同一种结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    point <span class="keyword">operator</span>+(<span class="type">const</span> point &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+obj.x,y+obj.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span>-(<span class="type">const</span> point &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-obj.x,y-obj.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">norm</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y+<span class="number">0.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">norm2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*x+y*y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a-b).<span class="built_in">norm</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-点积和叉积"><a href="#2-1-点积和叉积" class="headerlink" title="2.1 点积和叉积"></a>2.1 点积和叉积</h3><p>在计算几何中，向量的点积和叉积是有效的判断方向的手段，在只需要定性而不需要定量的向量朝向分析时，点积和叉积可以胜任绝大多数求角度&#x2F;求斜率操作能求解的问题。<br><img src="https://img-blog.csdnimg.cn/20200507202419129.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图2.1.1"><br>使用叉积可以判断给定向量在原向量基础上左偏还是右偏，使用点积可以判断给定向量和原向量正向还是反向。不难发现，点积满足交换率，而叉积不满足交换律。</p>
<p>规定 $\times (det)$ 表示叉积 $· (dot)$ 表示点积，有二维语境下的定义如下：</p>
<p>$$\vec{a}\times\vec{b} &#x3D; a.x  * b.y - a.y <em>b.x &#x3D; |a|</em>|b|*sin&lt;\vec{a},\vec{b}&gt;$$</p>
<p>$$\vec{a}  · \vec{b} &#x3D; a.x  * b.x + a.y <em>b.y &#x3D; |a|</em>|b|*cos&lt;\vec{a},\vec{b}&gt; $$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">det</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">det</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">det</span>(a-o,b-o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.x+a.y*b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(a-o,b-o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，不难发现叉积的绝对值同时是两向量构成的四边形的面积，所以可以通过叉积快速求出三角形面积。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfTriangle</span><span class="params">(<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b,<span class="type">const</span> point &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">det</span>(a,b,c)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-线段-直线"><a href="#2-2-线段-直线" class="headerlink" title="2.2 线段(直线)"></a>2.2 线段(直线)</h3><p>线段主要有四种储存方式，两点式，点向式，一般式，斜率式。</p>
<p>一般都以两点式存储，因为其不受斜率限制，可以表示任意一条直线，并且可以表示线段的范围，优势比较明显，此外还可以表示方向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span>&#123;</span><br><span class="line">	point s,t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在计算方程时，斜率式和一般式更为常用，尤其联立解一次以上方程时，常用斜率式，此时需要注意确认是否是铅直线，以防出现除<code>0</code>的<code>RE</code>。</p>
<p>对于两点式 $l(s,t)$，若 $s.x&#x3D;&#x3D;t.x$ 则为铅直线，需要另行讨论；否则有：</p>
<p>$$k&#x3D;\frac{(s.y-t.y)}{(s.x-t.x)}$$</p>
<p>$$b&#x3D;s.y-k*s.x$$</p>
<p>如此便可以从两点式转换为斜率式，反过来处理只需代入端点计算即可。至于两点式和点向式的转换，斜率式和一般式的转换，都较为简单，此处不表。一般而言，我们所说的直线均默认以两点式存储。</p>
<h4 id="2-2-1-点在线段上判定"><a href="#2-2-1-点在线段上判定" class="headerlink" title="2.2.1 点在线段上判定"></a>2.2.1 点在线段上判定</h4><p>点在线段上等价于</p>
<ul>
<li>点在对应直线上</li>
<li>点的横纵坐标在对应范围内</li>
</ul>
<p>一般而言，在处理问题时，如图形交点，常用直线先求出所有交点，再判断是否在所求线段上，所以第一条条件一般总是满足。大多数情况下只要快速判断第二条即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPointOnSegment</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> mix=<span class="built_in">min</span>(l.s.x,l.t.x);</span><br><span class="line">	<span class="type">double</span> mxx=<span class="built_in">max</span>(l.s.x,l.t.x);</span><br><span class="line">	<span class="type">double</span> miy=<span class="built_in">min</span>(l.s.y,l.t.y);</span><br><span class="line">	<span class="type">double</span> mxy=<span class="built_in">max</span>(l.s.y,l.t.y);</span><br><span class="line">    <span class="keyword">return</span> mix&lt;=o.x&amp;&amp;o.x&lt;=mxx&amp;&amp;miy&lt;=o.y&amp;&amp;o.y&lt;=mxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-线线交求交点"><a href="#2-2-2-线线交求交点" class="headerlink" title="2.2.2 线线交求交点"></a>2.2.2 线线交求交点</h4><p>如果是直线，直接转为一般式求解即可。如果是线段，只要在此基础上加上点在线段上判定即可。需要说明的是有必要特判斜率不存在的特殊情况。<del>一个玄学的处理方法是开始对所有点旋转一个特定角度以卡掉铅直线，避免讨论。</del> </p>
<h4 id="2-2-3-线线交判定"><a href="#2-2-3-线线交判定" class="headerlink" title="2.2.3 线线交判定"></a>2.2.3 线线交判定</h4><p>此处判定特指线段交，因为在欧氏二维空间中，直线不平行必定相交。可以用上述方法进行大讨论，也可以采用快速排斥+跨立实验的方法。</p>
<p>快速排斥实验指：判断两线段所在平行于坐标轴的矩形是否相交。</p>
<p>跨立实验指是指：判断对任意一条线段，另一线段两端点是否在其两侧。</p>
<p>需要说明的是，如果不能通过跨立实验，说明那么必定不可能相交；如果通过夸跨立实验而不通过快速排斥实验，则说明两条直线共线且有交点。</p>
<p>该判定方法有较多文字资料，可以自行查阅。</p>
<h4 id="2-2-4-点线距"><a href="#2-2-4-点线距" class="headerlink" title="2.2.4 点线距"></a>2.2.4 点线距</h4><p>点到直线距离有一般式公式：<br>$$d&#x3D;\frac{|Ax+By+C|}{\sqrt{x^2+y^2}}$$</p>
<p>但是这种写法需要对两点式进行变形，较为麻烦，一般采用面积除以底的形式，利用叉积的性质可以直接得到点 $O$ 到线段 $A,B$ 的距离：<br>$$d&#x3D;\frac{\vec{OA}\times\vec{OB}}{|\vec{AB}|}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">det</span>(o,l.s,l.t)/<span class="built_in">dis</span>(l.s,l.t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-圆和三角函数"><a href="#3-圆和三角函数" class="headerlink" title="3 圆和三角函数"></a>3 圆和三角函数</h2><p>圆往往和角度有关，所以在本节中，将圆和三角函数放在一起进行讨论。</p>
<p>圆心和半径可以唯一确定一个圆，因此给出圆的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">    point cn;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便起见，在本节中，如无特殊说明，所有的角度均为弧度制。</p>
<h3 id="3-1-正弦定理和余弦定理"><a href="#3-1-正弦定理和余弦定理" class="headerlink" title="3.1 正弦定理和余弦定理"></a>3.1 正弦定理和余弦定理</h3><p>在诸如X点共圆的题目中，求圆心角是一个常见操作。圆心角的一个更一般的表述是，对于给定一点引出的两条向量，求他们之间的夹角(即三角形内角)。<br><img src="https://img-blog.csdnimg.cn/20200508094631559.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图3.1.1"><br>用余弦定理可以容易的得到三角函数值：<br>$$\cos\theta&#x3D;\frac{a^2+b^2-c^2}{2ab}$$<br>如果已知各点均在圆上，在等腰三角形的情况下，可以用正弦定理解三角方程：<br>$$\frac{\sin\theta}{c}&#x3D;\frac{\sin(\frac{\pi-\theta}{2})}{r}$$<br>当然，直接通过叉积和点积求三角函数也可以，精度相差不大。</p>
<h3 id="3-2-反三角函数求角度"><a href="#3-2-反三角函数求角度" class="headerlink" title="3.2 反三角函数求角度"></a>3.2 反三角函数求角度</h3><p>求角度一般而言都绕不过反三角函数，所以角度和图形的转换势必会有较大的精度损失，建议尽量减少求角度的操作。在使用反三角函数时，一般使用<code>acos</code>而不是用<code>asin</code>，因为<code>acos</code>的值域为 $[0,\pi]$<br>，而<code>asin</code>的值域为 $[-\frac{\pi}{2},\frac{\pi}{2}]$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="number">1.0</span>*<span class="built_in">dot</span>(o,a,b)/<span class="built_in">dis</span>(a,o)/<span class="built_in">dis</span>(b,o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了减少求三角函数过程中求向量模长带来的精度损失，也可以使用<code>atan2</code>减少一步开根操作，提高精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">	point da=a-o;</span><br><span class="line">	point db=b-o;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>(<span class="number">1.0</span>*da.y,<span class="number">1.0</span>*da.x)-<span class="built_in">atan2</span>(<span class="number">1.0</span>*db.y,<span class="number">1.0</span>*db.x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后一种做法的好处不止在于精度，而且去掉<code>fabs</code>后还可以得到有向的角度，适用性更广泛。劣势在于不能同时得到三角函数值。</p>
<h3 id="3-3-扇形面积"><a href="#3-3-扇形面积" class="headerlink" title="3.3 扇形面积"></a>3.3 扇形面积</h3><p>以下两节是圆操作中比较基础的内容，多见于多边形和圆面积交的前置操作。</p>
<p>扇形面积比较简单，有类似三角形的面积公式<br>$$S&#x3D;\frac{RL}{2}&#x3D;\frac{L^2\alpha}{2}$$<br>其中半径为 $R$ 弧长为 $L$，有对应弧度为 $\alpha&#x3D;\frac{L}{R}$。</p>
<p>这样直接调用上一节的角度公式即可求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfSector</span><span class="params">(<span class="type">const</span> circle &amp;c,<span class="type">const</span> point &amp;a,<span class="type">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">angle</span>(c.cn,a,b)*c.r*c.r/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-圆和线段交"><a href="#3-4-圆和线段交" class="headerlink" title="3.4 圆和线段交"></a>3.4 圆和线段交</h3><p>圆和线段很不好交，因为线段有长度限制。比较好的处理方法是先和直线交，再判断是否在线段上，调用2.2.1节的判定函数。</p>
<p>判断关于直线解个数可以直接用圆心距判断，求交点则可以联立解方程(解方程时的<code>delta</code>值也可以直接用来判断解个数)。</p>
<p>作者尝试过使用向量做法解交点，但是因为在求解过程中大量使用开根操作(向量模)对向量进行缩放，导致巨大精度损失，所以建议还是使用丑陋的斜率式方程求解，特判垂直情况。在上交的算法书里，介绍了一种点向式带入圆方程的解法，也不失为一种巧妙的解法，用向量规避了无意义的斜率不存在的讨论，同时又利用解析方法避免纯向量方法频繁求模长带来的开根精度损失。</p>
<h4 id="3-4-1-点斜式解法"><a href="#3-4-1-点斜式解法" class="headerlink" title="3.4.1 点斜式解法"></a>3.4.1 点斜式解法</h4><p>因为这里涉及到求交点问题，所以在上面point类中应该将成员函数定义为double。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">polygon <span class="title">circleIntersectSegment</span><span class="params">(<span class="type">const</span> circle &amp;c,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">    polygon ret;</span><br><span class="line">    point a=l.s,b=l.t;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x)&#123;</span><br><span class="line">        <span class="type">double</span> d=<span class="built_in">fabs</span>(c.cn.x-a.x);</span><br><span class="line">        <span class="keyword">if</span>(d&lt;c.r)&#123;</span><br><span class="line">            <span class="type">double</span> dy=<span class="built_in">sqrt</span>(c.r*c.r-d*d);</span><br><span class="line">            point p1=&#123;a.x,c.cn.y+dy&#125;;</span><br><span class="line">            point p2=&#123;a.x,c.cn.y-dy&#125;;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p1,l))ret.<span class="built_in">push_back</span>(p1);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p2,l))ret.<span class="built_in">push_back</span>(p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">double</span> k=(b.y-a.y)/(b.x-a.x);</span><br><span class="line">        <span class="type">double</span> bb=a.y-k*a.x;</span><br><span class="line">        <span class="type">double</span> x0=c.cn.x;</span><br><span class="line">        <span class="type">double</span> y0=c.cn.y;</span><br><span class="line">        <span class="type">double</span> A=k*k+<span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> B=<span class="number">2</span>*(k*(bb-y0)-x0);</span><br><span class="line">        <span class="type">double</span> C=x0*x0+(bb-y0)*(bb-y0)-c.r*c.r;</span><br><span class="line">        <span class="type">double</span> delta=B*B<span class="number">-4</span>*A*C;</span><br><span class="line">        <span class="keyword">if</span>(delta&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> t1=(-B+<span class="built_in">sqrt</span>(delta))/<span class="number">2</span>/A;</span><br><span class="line">            <span class="type">double</span> t2=(-B-<span class="built_in">sqrt</span>(delta))/<span class="number">2</span>/A;</span><br><span class="line">            point p1=&#123;t1,k*t1+bb&#125;;</span><br><span class="line">            point p2=&#123;t2,k*t2+bb&#125;;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p1,l))ret.<span class="built_in">push_back</span>(p1);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPointOnSegment</span>(p2,l))ret.<span class="built_in">push_back</span>(p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文中<code>polygon</code>就是<code>vector&lt;point&gt;</code>，该定义会在第四节中给出。方便起见，相切情况，我们默认产生了两个重合的交点，这样可以避免一些容易产生精度误差的讨论。</p>
<h4 id="3-4-2-点向式解法"><a href="#3-4-2-点向式解法" class="headerlink" title="3.4.2 点向式解法"></a>3.4.2 点向式解法</h4><p>设线段一个端点为 $A(x_a,y_a)$ ，到另一个端点的向量 $\vec{AB}(dx,dy)$，得到向量式 $$P(x_a+t<em>dx,y_a+t</em>dy)\in Circle$$</p>
<p>带入圆方程 $(x-x_0)^2+(y-y_0)^2&#x3D;r^2$ 可以得到一个形如 $At^2Bt+C&#x3D;0$ 的一元二次方程，有<br>$$A&#x3D;dx^2+dy^2$$</p>
<p>$$B&#x3D;2*(dx*(x_a-x_0)+dy*(y_a-y_0))$$</p>
<p>$$C&#x3D;(x_a-x_0)^2+(y_a-y_0)^2-r^2$$</p>
<p>直接求解即可。</p>
<h2 id="4-简单多边形"><a href="#4-简单多边形" class="headerlink" title="4 简单多边形"></a>4 简单多边形</h2><p>任何一个简单多边形都可以被认为是一连串点分别连向他们的前驱和后继，所以在存储时，我们只要存储一个有序的点的序列即可。需要说明的是，因为简单，所以要保证没有任何两条线段相交。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;point&gt; polygon;</span><br></pre></td></tr></table></figure>

<p>此外，我们默认头节点和尾节点在多边形存储中是同一节点，因为凸包自成环，不存在逻辑意义上的首尾，所以经常要另行处理头节点和尾节点，方便起见将其存储在两端，就可以避免许多讨论。</p>
<h3 id="4-1-凸包"><a href="#4-1-凸包" class="headerlink" title="4.1 凸包"></a>4.1 凸包</h3><p>凸包是绝大多是计算几何问题的核心，在没有圆的情况下尤其如此。对二维凸包的一个感性认识是：在一个平面上有一堆钉子，用一个橡皮筋把他们套起来，橡皮筋的形状结就是这些点构成的凸包。</p>
<p>对于凸包更深入的了解建议进一步观看邓俊辉老师的《计算几何》课程凸包章节，在课程中对凸包能够处理的绝大多数问题都进行了解答和证明。在本文中，本文只会提供一些粗浅的结论，方便读者快速掌握所需知识。</p>
<p>需要说明的是，求凸包的理论下界是 $O(log_2n)$ 的，可以规约到排序问题来证明。对于任意一个排序问题，可以将他们的值在线性时间内映射到二维空间中的一根辅助线(如抛物线)上，调用凸包算法，并且在线性时间内遍历输出得到排序结果。如此就通过规约方法证明了凸包求解算法的理论复杂度下界。</p>
<h4 id="4-1-1-判断点在凸包内"><a href="#4-1-1-判断点在凸包内" class="headerlink" title="4.1.1 判断点在凸包内"></a>4.1.1 判断点在凸包内</h4><p>要求凸包，其实就是要把所有在凸包内的点删去，所以先观察凸包内点的性质。</p>
<p>凸包有如下性质：凸包内所有点都在凸包上有向线段的同一侧。用叉积的说法来说，叉出来的结果正负性是一致的。这点不难从观察中发现。于是我们定义<code>toLeft</code>测试，判断点和有向线段的位置关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isToLeft</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> segment &amp;l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">det</span>(l.s,l.t,o)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值为<code>1</code>说明点在有向线段左侧。如果对所有凸包上所有线段返回值都一致，那么说明点在凸包内。因为不知道凸包旋转方向，所以要做两轮测试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPointInConvexHull</span><span class="params">(<span class="type">const</span> point &amp;o,<span class="type">const</span> polygon &amp;p)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isToLeft</span>(o,(segment)(p[i],p[i+<span class="number">1</span>])))tmp=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span> tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isToLeft</span>(o,(segment)(p[i+<span class="number">1</span>],p[i])))tmp=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要允许点在凸包上，将<code>toLeft</code>测试中<code>&gt;</code>替换为<code>&gt;=</code>即可。</p>
<h4 id="4-1-2-求凸包"><a href="#4-1-2-求凸包" class="headerlink" title="4.1.2 求凸包"></a>4.1.2 求凸包</h4><p>从上一节中，得到一个点在凸包内部的充要条件。现在我们讨论，如何求解凸包。假设已知一条有向边，那么考虑这条有向两侧的点，显然如果两侧都有点，那么这条边必定不在凸包上；反之必定在凸包上。如果能将所有点的角度排序，就可以在线性时间内得到凸壳。排序法+单调栈的凸包算法就是基于该原理，将所有点按照某种顺序排序，然后根据旋转角来决定进栈出栈，算法完成时即得到最终结果。而旋转角可以通过叉积来代替，以避免弱智的三角函数操作。</p>
<p>常见的排序法有graham法和andrew法，他们分别通过极角排序和水平序排序来实现。</p>
<p>Graham先选取一个在凸包上的枢轴点(如横坐标最小的点)，按照极角排序，然后单调栈跑一圈即可。<br><img src="https://img-blog.csdnimg.cn/20200508120139593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="图4.1.2.1"><br>Andrew则是按照水平序排序，然后分上下凸壳跑两次单调栈。两种做法其实并没有太大区别，但是个人比较喜欢水平序排序，因为看起来比较优美（因为不需要另外找一个枢轴点，排水平序的时候自然产生了）。事实上，两者的原理是完全一样的，水平序可以认为是关于一个无穷高的点的极角序。<br><img src="https://img-blog.csdnimg.cn/20200508120656917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.1.2.2"></p>
<p>此处只给出水平序的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">polygon <span class="title">convexHull</span><span class="params">(polygon p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    polygon ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">det</span>(*ret.<span class="built_in">rbegin</span>(),*++ret.<span class="built_in">rbegin</span>(),p[i])&lt;=<span class="number">0</span>)ret.<span class="built_in">pop_back</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=ret.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p.<span class="built_in">size</span>()<span class="number">-2</span>;~i;--i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()&gt;m&amp;&amp;<span class="built_in">det</span>(*ret.<span class="built_in">rbegin</span>(),*++ret.<span class="built_in">rbegin</span>(),p[i])&lt;=<span class="number">0</span>)ret.<span class="built_in">pop_back</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此段代码中求出凸包，初始点会在末尾位置出现</span></span><br><span class="line">    <span class="comment">// ret.pop_back();</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要求三点共线的情况下，在凸包上点的个数，则将<code>det</code>后面的比较操作符进行修改即可。</p>
<h4 id="4-1-3-旋转卡壳"><a href="#4-1-3-旋转卡壳" class="headerlink" title="4.1.3 旋转卡壳"></a>4.1.3 旋转卡壳</h4><p>众所周知旋转卡壳有16种读法。但是其用法相对单一：在 $O(n)$ 时间内计算给定凸上的所有对踵点。感性认识对踵点，就是从某个点出发，能走到的最远点，这两个点构成一组对踵点。更科学的表述是，如果能用一组平行线将凸包包裹，那么在平行线上的点对都是对踵点。在凸包上，该关系具有对称性。</p>
<p>从平行线的定义不难看出，该算法可以在 $O(n)$ 时间内快速求出凸包最远点对&#x2F;最远点线距。</p>
<p>不难发现，对于一个点而言，所有有序的其他点和他的距离是一个单峰函数，一次查询可以使用三分法实现。对于全部点对，则可以采用双指针法，这就是旋转卡壳的基本思想。</p>
<p>以下给出一个最远点线距的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">rotateCalipers</span><span class="params">(polygon P)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">1e15</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p]))&lt;<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p+<span class="number">1</span>])))&#123;</span><br><span class="line">            ++p;</span><br><span class="line">            p%=P.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">abs</span>(<span class="built_in">det</span>(P[i],P[i+<span class="number">1</span>],P[p]));</span><br><span class="line">        tmp/=<span class="built_in">dis</span>(P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">        ret=<span class="built_in">min</span>(tmp,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要计算对踵点或者最远点对的话，只要修改<code>while</code>内的比较函数为点和点之间的距离即可。</p>
<h3 id="4-2-三角剖分"><a href="#4-2-三角剖分" class="headerlink" title="4.2 三角剖分"></a>4.2 三角剖分</h3><p>当所求与面积有关时，可以用带正负面积的三角剖分来实现问题的简化。任意选取一点作为基点 $o$，和简单多边形上有向相邻的两点 $p_i,p_{i+1}$ 组成三角形，根据叉积 $det(o,p_i,p_{i+1})$ 判断正负性即可。</p>
<h4 id="4-2-1-面积"><a href="#4-2-1-面积" class="headerlink" title="4.2.1 面积"></a>4.2.1 面积</h4><p>求简单多边形面积只要直接暴力模拟上述过程求解即可。枢轴点可以直接选取原点，注意点类要设置为<code>double</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> point o=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfPolygon</span><span class="params">(<span class="type">const</span> polygon &amp;P)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        ret+=<span class="built_in">det</span>(o,P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ret/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-重心"><a href="#4-2-2-重心" class="headerlink" title="4.2.2 重心"></a>4.2.2 重心</h4><p>简单多边形的重心不易求解，但是三角形重心就是三点坐标均值。进行三角剖分后，对各三角形按照面积求加权平均值即可得到简单多边形重心。枢轴点也可以直接选取原点，注意点类要设置为<code>double</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> point o=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="function">point <span class="title">centroidOfPolygon</span><span class="params">(<span class="type">const</span> polygon &amp;P)</span></span>&#123;</span><br><span class="line">    point ret=&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="type">double</span> tmp=<span class="built_in">det</span>(o,P[i],P[i+<span class="number">1</span>]);</span><br><span class="line">        ret=ret+(point)&#123;(P[i].x+P[i+<span class="number">1</span>].x)*tmp,(P[i].y+P[i+<span class="number">1</span>].y)*tmp&#125;;</span><br><span class="line">        sum+=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;ret.x/sum/<span class="number">3</span>,ret.y/sum/<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-与圆面积交"><a href="#4-2-3-与圆面积交" class="headerlink" title="4.2.3 与圆面积交"></a>4.2.3 与圆面积交</h4><p>选取圆心为枢轴点进行三角剖分后，可以计算一点在圆心的三角形和原的面积交。接下来只要进行分类讨论即可。</p>
<p>可以简单分为四类：全在里面，一个角在外面，全在外面(不相交，相交)。对于全在外面且相切的情况吗其实和不相交的结果一致，所以可以直接忽略，视为不相交即可。<br><img src="https://img-blog.csdnimg.cn/20200508123202396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.2.3.1"><br>我们采用的处理手段是把他们分解成扇形和三角形进行处理。<br><img src="https://img-blog.csdnimg.cn/20200508123238601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="4.2.3.2"><br>如此便是一堆大讨论的操作。</p>
<p>看起来很复杂的讨论，其实在实现的时候可以通过一些技术手段来规避多数的讨论，从而降低编程的负担。</p>
<p>作者采用的方案是：对两点排序，将离圆心近的视为内点，另一个视为外点。再判断交点个数，如果没有交点，那么要么全内，要么全外，判断任意一点位置即可；如果有一个交点，那么一定是内点到交点为三角，交点到外点为扇面；如果有两个交点，那么一定是两侧扇面，中间三角，即两个交点构成三角，对于原线段上每一个点，找两个交点中较近的一个，构成扇面（如果将相切视为一种情况，则讨论会复杂很多）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">areaOfCircleIntersectSegment</span><span class="params">(<span class="type">const</span> circle &amp;c,point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dis</span>(c.cn,a)&gt;<span class="built_in">dis</span>(c.cn,b))<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dis</span>(c.cn,b)&lt;=c.r)&#123;</span><br><span class="line">        ret=<span class="built_in">areaOfTriangle</span>(c.cn,a,b);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        polygon p=<span class="built_in">circleIntersectSegment</span>(c,a,b);</span><br><span class="line">        <span class="keyword">switch</span> (p.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ret=<span class="built_in">areaOfSector</span>(c,a,b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ret=<span class="built_in">areaOfTriangle</span>(c.cn,a,p[<span class="number">0</span>])+<span class="built_in">areaOfSector</span>(c,p[<span class="number">0</span>],b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dis</span>(p[<span class="number">0</span>],a)&gt;<span class="built_in">dis</span>(p[<span class="number">1</span>],a))<span class="built_in">swap</span>(p[<span class="number">0</span>],p[<span class="number">1</span>]);</span><br><span class="line">            ret=<span class="built_in">areaOfTriangle</span>(c.cn,p[<span class="number">0</span>],p[<span class="number">1</span>])+<span class="built_in">areaOfSector</span>(c,a,p[<span class="number">0</span>])+<span class="built_in">areaOfSector</span>(c,b,p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>areaOfTriangle</code>，<code>areaOfSector</code>，<code>circleIntersectSegment</code>，<code>dis</code>均为上文提及前置函数。</p>
<h2 id="5-数值计算"><a href="#5-数值计算" class="headerlink" title="5 数值计算"></a>5 数值计算</h2><p>众所周知，数形结合是解决几何问题的一大法宝。当遇到一坨扭曲的丑陋的图形的时候，解析计算实在太费事了，这个时候数值计算就可以充分利用计算机的算力优势，来暴力解决本该积分&#x2F;解方程解决的问题。</p>
<h3 id="5-1-插值法"><a href="#5-1-插值法" class="headerlink" title="5.1 插值法"></a>5.1 插值法</h3><p>插值法解决这样一类问题：给定一系列的二维离散点，再未定义的位置补差连续函数，使得其通过所有给定离散点。换言之，建立一条关于给定点的拟合函数。</p>
<p>以下介绍的拉格朗日插值和牛顿插值都属于代数插值，在不考虑精度的情况下得到的结果是一致的。因为 $n$ 个点构造的一元 $n-1$ 次方程是唯一的。用待定系数法，列方程，克拉默法则求解易证结果的唯一性。</p>
<h4 id="5-1-1-拉格朗日插值"><a href="#5-1-1-拉格朗日插值" class="headerlink" title="5.1.1 拉格朗日插值"></a>5.1.1 拉格朗日插值</h4><p>拉格朗日插值的核心思想是，对于 $n$ 个点，构造一个 $n$  项的多项式，当 $x&#x3D;x_i$ 时，使第 $i$ 项为 <code>1</code>；当 $x\not&#x3D;x_i$ 时，使第 $i$ 项为 <code>0</code>。</p>
<p>对于给定的 $n$ 个点 $(x_0,y_0),(x_1,y_1)\dots(x_{n-1},y_{n-1})$，可以构造如下插值多项式</p>
<p>$$P(x)&#x3D;\sum_{i&lt;n}\prod_{i\not&#x3D;j,j&lt;n}\frac{x-x_j}{x_i-x_j}y_i$$</p>
<p>举个例子，如果有两项，那么插值多项式为</p>
<p>$$f(x)&#x3D;\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1$$</p>
<p>如此达到了离线的 $O(n^2)$ 复杂度的单次构造，查询。</p>
<h4 id="5-1-2-牛顿插值"><a href="#5-1-2-牛顿插值" class="headerlink" title="5.1.2 牛顿插值"></a>5.1.2 牛顿插值</h4><p>拉格朗日插值主要的劣势在于，当插入一个新点时，整个函数需要重新进行计算，影响程序性能；进行了大量的除法运算，引入了浮点误差。</p>
<p>牛顿插值法在逻辑上可以得到和拉格朗日插值法一样的结果，但是在精度上更有优势，并且有着更强的拓展性。</p>
<p>要介绍牛顿插值法的基本原理，要先从低维情形说起，当只有一个点 $(x_0,y_0)$ 时，直接构造<br>$$f_0(x)&#x3D;y_0$$<br>函数总是通过这个点。</p>
<p>接下来加入一个点 $(x_1,y_1)$，我们希望不影响之前经过的点，并且在此基础上经过新点，于是构造一个 $b_1(x-x_0)$ 的累加项使得新函数不影响函数在 $x&#x3D;x_0$ 处的函数值，即<br>$$f_1(x)&#x3D;f_0(x)+b_1(x-x_0)$$<br>代入 $(x_1,y_1)$ 可以求出 $b_1$，从而也能通到新点上。</p>
<p>再加入点 $(x_2,y_2)$，类似地，构造<br>$$f_2(x)&#x3D;f_1(x)+b_2(x-x_0)(x-x_1)$$<br>解出 $b_2$ 即可。迭代展开即可得到牛顿插值多项式，当插入新点时，按照上述操作继续拓展即可，每次解 $b$ 都是求一个一元一次函数的过程。</p>
<p>更一般地表述是，令<br>$$\phi_i(x)&#x3D;\prod_{j&lt;i}(x-x_j)$$<br>有牛顿插值多项式<br>$$f(x)&#x3D;\sum_{i&lt;n}b_i\phi_i(x)$$</p>
<p>一般牛顿迭代法使用差商的方式实现。定义差商<br>$$f[x_{n-1},x_{n-2}\cdots x_0]&#x3D;\frac{f[x_{n-1}\cdots x_1]-f[x_{n-2}\cdots x_0]}{x_{n-1}-x_0}$$</p>
<p>且<br>$$f[x_i]&#x3D;f(x_i)$$</p>
<p>经过一通乱算(这里相关证明可以自行查询相关文献，如《自然哲学的数学原理》)，可以发现<br>$$f[x_{n},x_{n-1}\cdots x_0]&#x3D;b_n$$</p>
<p>则有牛顿插值多项式最终表达式<br>$$f(x) &#x3D;  f[x_0]+f<a href="x-x_0">x_1,x_0</a>+\dots+f<a href="x-x_%7Bn-2%7D">x_{n-1},x_{n-2}\dots x_0</a>\cdots(x-x_0)$$</p>
<p>在计算时，用二维数组记录各次差商即可，最终得到的三角矩阵最下一排即是上述系数。可以在 $O(n^2)$ 时间内在线计算，求解。</p>
<h4 id="5-1-3-分段线性插值"><a href="#5-1-3-分段线性插值" class="headerlink" title="5.1.3 分段线性插值"></a>5.1.3 分段线性插值</h4><p>分段线性插值是一种比较朴素的插值方案，即对每个横坐标相邻的两点见连线得到一条过所有所求点的折线。但是这种做法得到的函数不连续，且因为形式过于简单，拟合效果无法得到保证。</p>
<h3 id="5-2-数值积分"><a href="#5-2-数值积分" class="headerlink" title="5.2 数值积分"></a>5.2 数值积分</h3><p>数值积分用来通过暴力手段计算积分。如果一个积分可以通过计算得到，那么就不需要暴力，这里我们讨论的都是难以(或者懒得)通过计算积分得到的情况。</p>
<p>一个比较简单的策略是取一些等距的点，使用上一节中介绍的插值法构造拟合函数，然后对构造出来的函数积分。因为保证是一元高次多项式，所以积分相对容易且可积。但是在高次情形下该方法有着较大的局限性。</p>
<p>另一种数值积分的方案是使用定积分的定义，分割成条，对每个长条用梯形面积公式计算(类似分段线性插值后分段积分)。但是当遇到一些不那么友好的函数时，这种做法很容易发生精度爆炸的惨案。</p>
<h4 id="5-2-1-牛顿-柯斯特公式"><a href="#5-2-1-牛顿-柯斯特公式" class="headerlink" title="5.2.1 牛顿-柯斯特公式"></a>5.2.1 牛顿-柯斯特公式</h4><p>牛顿-柯斯特公式对于上述切条分别求面积再求和的算法的拓展。若要对区间 $I&#x3D;[a,b]$ 积分，先对其进行等分，得到 $x_k&#x3D;a+k·\frac{b-a}{n} (k&#x3D;0,1,\cdots,n)$ ，求各个数值 $f(x_i)$，对这 $n+1$ 个点进行拉格朗日插值，然后再对得到的 $n$ 次多项式积分。</p>
<p>令步长 $h&#x3D;\frac{b-a}{n}$，有<code>Cotes</code>系数 $C_k^{(n)}$ 满足<br>$$C_k^{(n)}&#x3D;\frac{h}{b-a}\int_0^n\prod_{j\leq n,j\not&#x3D;k}\frac{t-j}{k-j}\text{d}t&#x3D;\frac{(-1)^{n-k}}{nk!(n-k)!}\int_0^n\prod_{j\leq n,j\not&#x3D;k}(t-j)\text{d}t$$ </p>
<p>且有数值积分公式<br>$$\int_a^bf(x) \approx(b-a)\sum_{k&#x3D;0}^nC_k^{(n)}f(x_k)$$</p>
<p>当取 $n&#x3D;1$ 时(也就是将积分区间切成一块)，可以得到朴素的梯形公式<br>$$C_0^{(1)}&#x3D;C_1^{(1)}&#x3D;\frac{1}{2}$$</p>
<p>$$\int_a^bf(x) \approx\frac{b-a}{2}[f(a)+f(b)]$$</p>
<h4 id="5-2-2-辛普森积分"><a href="#5-2-2-辛普森积分" class="headerlink" title="5.2.2 辛普森积分"></a>5.2.2 辛普森积分</h4><p>当 $n&#x3D;2$ 时(切成两块)，可以得到辛普森积分公式。<br>$$C_0^{(2)}&#x3D;C_2^{(2)}&#x3D;\frac{1}{6}\ ,\ C_1^{(2)}&#x3D;\frac{4}{6}$$</p>
<p>$$\int_a^bf(x) \approx\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]$$</p>
<h4 id="5-2-3-自适应辛普森积分"><a href="#5-2-3-自适应辛普森积分" class="headerlink" title="5.2.3 自适应辛普森积分"></a>5.2.3 自适应辛普森积分</h4><p>辛普森积分是最常用的数值积分公式，他只比梯形公式多了一项，却把代数精度提高到了3，可以精确拟合三次及以下的函数。但是如果被积函数只有三次，大可以直接手算积分，当遇到更高次甚至是非多项式函数时，我们需要更加有力的武器。</p>
<p>根据类似积分定义的思路，如果我们将原函数分割的越细密，精度自然就越高。自适应辛普森积分通过对原问题进行分治来取得更高的精度：如果一个辛普森积分精度不够，那就两个。</p>
<p>不妨设被积函数 $f(x)$ ，要对区间 $I&#x3D;[a,b]$ 积分。则有朴素辛普森公式：<br>$$F(a,b)\approx\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]$$</p>
<p>令中点 $m&#x3D;\frac{a+b}{2}$ ，如果发现分治进行数值积分的结果和直接数值积分的结果之差小于所需精度，即<br>$$|F(a,b)-F(a,m)-F(m,b)|\leq eps$$<br> 那么直接返回当前结果，否则分治处理两个子问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>-x+x*x-x*x*x*x+x*x*x*x*x;<span class="comment">//any arbitrary function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">F</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">f</span>(a)+<span class="number">4</span>*<span class="built_in">f</span>((a+b)/<span class="number">2</span>)+<span class="built_in">f</span>(b))/<span class="number">6</span>*(b-a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">simpson</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> eps)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> m=(a+b)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">double</span> s=<span class="built_in">F</span>(a,b),l=<span class="built_in">F</span>(a,m),r=<span class="built_in">F</span>(m,b);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(s-a-l)&lt;eps)<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">simpson</span>(a,m,eps)+<span class="built_in">simpson</span>(m,b,eps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6 结语"></a>6 结语</h2><p>本文主要介绍了关于计算几何的一些基本知识和思想，并以此为基础简单介绍一些算法。本文的点，向量，圆部分的模板部分借鉴了上交俞勇老师主编的《ACM国际大学生程序设计竞赛算法与实践》，一些计算几何相关但是不太常用的算法，诸如求多边形的核等算法，本文并未涉及，感兴趣的读者可以自行查阅。在凸包部分的证明，作者主要参考了邓俊辉老师的《计算几何》。本文最后数值计算部分则主要从《数值计算》和部分博客中归纳总结而来，因为有些内容年代比较久远，故无法确定来源，如有兴趣可自行查找相关资料。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E4%B8%89%E8%A7%92%E5%BD%A2%E5%A4%96%E5%BF%83%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E4%B8%89%E8%A7%92%E5%BD%A2%E5%A4%96%E5%BF%83%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">三角形外心计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:08:08 / Modified: 16:08:37" itemprop="dateCreated datePublished" datetime="2022-09-04T16:08:08+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定二维平面上三个不共线的点 $A(x_0,y_0),B(x_1,y_1),C(x_2,y_2)$, 求出他们形成的圆的圆心和半径。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>计算几何问题常用数形结合解决，不妨设圆心 $O(x,y)$，则满足三个点到圆心的距离相同。我们可以用两个等价方程来描述：</p>
<p>$$(x-x_0)^2+(y-y_0)^2&#x3D;(x-x_1)^2+(y-y_1)^2\\(x-x_0)^2+(y-y_0)^2&#x3D;(x-x_2)^2+(y-y_2)^2\tag1$$</p>
<p>现在转换为两个方程解两个未知数 $x,y$ 的问题。上式化简后可得两个线性方程，使用<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99&rsv_t=612eshGkvGdcM+ks1IFegQMusSpoY8cpBN/PEcwy5PRcO/R4h/6HfdNPRT8&rsv_enter=1&rsv_dl=ib&rsv_sug3=10&rsv_sug1=6&rsv_sug7=100">克拉默法则</a>可以容易解出答案。</p>
<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>对公式 $(1)$ 分别移项展开消去二次项，得到：</p>
<p>$$2(x_1-x_0)x+2(y_1-y_0)y&#x3D;x_1^2-x_0^2+y_1^2-y_0^2\\2(x_2-x_0)x+2(y_2-y_0)y&#x3D;x_2^2-x_0^2+y_2^2-y_0^2\tag2$$</p>
<p>如此得到一组二元一次线性方程则，方程有解充要条件是系数矩阵行满秩，容易发现无解当且仅当三点共线，即行列式(同时也是三点形成两个向量的叉积)为0，即</p>
<p>$$(x_1-x_0)\times(y_2-y_0)-(x_2-x_0)\times(y_1-y_0)&#x3D;0\tag3$$</p>
<p>其他情况下均有解。方便起见以a,b,c,d,e,f,g来代替原系数，即：</p>
<p>$$ax+by&#x3D;c\\dx+ey&#x3D;f\tag4$$</p>
<p>其中：</p>
<p>$$a&#x3D;2(x_1-x_0)\\b&#x3D;2(y_1-y_0)\\c&#x3D;x_1^2-x_0^2+y_1^2-y_0^2\\d&#x3D;2(x_2-x_0)\\e&#x3D;2(y_2-y_0)\\f&#x3D;x_2^2-x_0^2+y_2^2-y_0^2\tag5$$</p>
<p>在有解情况下，由<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99&rsv_t=612eshGkvGdcM+ks1IFegQMusSpoY8cpBN/PEcwy5PRcO/R4h/6HfdNPRT8&rsv_enter=1&rsv_dl=ib&rsv_sug3=10&rsv_sug1=6&rsv_sug7=100">克拉默法则</a>可得</p>
<p>$$x &#x3D; \frac{D_x}{D} &#x3D; \frac{ce-fb}{ae-db}$$<br>$$y &#x3D; \frac{D_y}{D} &#x3D; \frac{af-dc}{ae-bd}\tag6$$</p>
<p>于是可在 $O(1)$ 内求出圆心，从而计算可得半径。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node <span class="title">findO</span><span class="params">(<span class="type">const</span> node &amp;p,<span class="type">const</span> node &amp;q,<span class="type">const</span> node &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//input should be nonlinear</span></span><br><span class="line">    <span class="type">double</span> a = <span class="number">2</span> * (p.x - q.x);</span><br><span class="line">    <span class="type">double</span> b = <span class="number">2</span> * (p.y - q.y);</span><br><span class="line">    <span class="type">double</span> c = p.x * p.x + p.y * p.y - q.x * q.x - q.y * q.y;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">2</span> * (p.x - r.x);</span><br><span class="line">    <span class="type">double</span> e = <span class="number">2</span> * (p.y - r.y);</span><br><span class="line">    <span class="type">double</span> f = p.x * p.x + p.y * p.y - r.x * r.x - r.y * r.y;</span><br><span class="line">    <span class="type">double</span> g = a*e-b*d;</span><br><span class="line">    <span class="keyword">return</span> &#123;(c*e-f*b)/g,(a*f-d*c)/g&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-6242/origin">Geometry Problem</a><br>其实本题并不是求圆心模板题，但是考虑到本题去掉思维部分可以被视为2-D版本三点共圆模板题，而且模板题确实难找，故当作模板题放在此处。</p>
<h2 id="高维情况"><a href="#高维情况" class="headerlink" title="高维情况"></a>高维情况</h2><h3 id="三维三角形外心"><a href="#三维三角形外心" class="headerlink" title="三维三角形外心"></a>三维三角形外心</h3><p>给定三维空间上三个不共线的点$A(x_0,y_0,z_0)$ , $B(x_1,y_1,z_1)$ , $C(x_2,y_2,z_2)$ , 求出他们形成的圆的圆心和半径。</p>
<p>依据数形结合思路，仍要先把几何问题转化为代数问题：<br>$$R &#x3D; (x-x_0)^2+(y-y_0)^2+(z-z_0)^2\\\ \ \ \ &#x3D; (x-x_1)^2+(y-y_1)^2+(z-z_1)^2\\\ \ \ &#x3D; (x-x_2)^2+(y-y_2)^2+(z-z_2)^2$$</p>
<p>其中 $(x,y,z)$ 为圆心坐标，于是得到三个未知数两个方程。要求解至少还需要一个方程。但是三个点可以确定一张平面，可以通过叉积得到法向量，构造平面方程，如此则转化为三元一次线性方程组，且方程系数比较容易求出。容易利用<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99&rsv_t=612eshGkvGdcM+ks1IFegQMusSpoY8cpBN/PEcwy5PRcO/R4h/6HfdNPRT8&rsv_enter=1&rsv_dl=ib&rsv_sug3=10&rsv_sug1=6&rsv_sug7=100">克拉默法则</a>求三阶行列式分别求出 $x,y,z$ 的数值。</p>
<h3 id="n维度三角形外心"><a href="#n维度三角形外心" class="headerlink" title="n维度三角形外心"></a>n维度三角形外心</h3><p>给定n维空间上三个不共线的点$A(x_0,y_0,z_0,…)$ , $B(x_1,y_1,z_1,…)$ , $C(x_2,y_2,z_2,…)$ , 求出他们形成的圆的圆心和半径。</p>
<p>类推处理二维和三维情况下的方案，设圆心为 $O(x,y,z,…)$。由等距性质得到两个线性方程。在n维空间下，表征一个二维平面平面，需要n-2个线性方程。于是综合上述两组方程得到n元一次线性方程组，高斯消元可以 $O(n^3)$ 处理得到方程的解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/cdq%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/cdq%E5%88%86%E6%B2%BB/" class="post-title-link" itemprop="url">cdq分治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:07:16 / Modified: 16:23:30" itemprop="dateCreated datePublished" datetime="2022-09-04T16:07:16+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><h2 id="陌上花开1"><a href="#陌上花开1" class="headerlink" title="陌上花开1"></a>陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a></h2><p>若干个元素有三个属性$a,b,c$，问多少对数对$（i,j）$满足 $$a_i\leq a_j  , b_i\leq b_j , c_i\leq c_j$$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如此类问题可以视为一个多维偏序问题，偏序即满足自反性，反对称性，传递性。画成拓扑图则可被视为一张DAG。</p>
<p>考虑这个问题的简单版本，如果只有一个属性，可以容易得到；如果有两个属性，常见的解决方案是对其中一维排序后，树状数组维护前缀，按照某一位以每个元素log的复杂度顺序处理。</p>
<p>在维度更高的情况下，cdq分治是简化问题的一个有效手段。</p>
<p>cdq分治的核心思想即以一个log为代价，降低此类多维偏序一个维度。</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="偏序和全序"><a href="#偏序和全序" class="headerlink" title="偏序和全序"></a>偏序和全序</h2><p>偏序即满足：自反性，反对称性，传递性的二元关系。<br>全序即满足：完全性，反对称性，传递性的二元关系。<br>两者唯一的区别是第一个性质，但是不难发现，自反性即 $$\forall x\ \ s.t. \ \ xRx$$<br>完全性即  $$\forall x,y\ \ s.t. \ \ xRy$$<br>即偏序只要自己和自己可比即可，全序则是集合内任意两个元素可比。</p>
<p>像我们处理了如例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>的多属性比较关系，往往是偏序的，因为可能出现 $a_i&gt;b_j,b_i&lt;b_j$的情况，两者不可比。而自然数集上的大小关系往往可以被视为全序关系，因为任意两个自然数都可比。</p>
<p>引申一点，在全序关系上我们引入良序的定义：若一个全序集上任意一个非空子集S都有最小元，则称其为良序。</p>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>求逆序对个数事实上可以被视为一个二位偏序的统计问题。对于序列A上每一个元素 $a_i$都有两个属性，位置 $i$ 和大小$a_i$，把他们全部揪出来可以形成一个偏序集。那么逆序对实质就是要求集合内所有满足如下关系的对$（i，j）$的数量: $$i&lt;j\ ,\ a_i&gt;a_j$$ 也即可比的元素对个数。</p>
<p>两种常见的计算方案如下: 从后往前求维护树状数组求解<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=cdd1a6a4001410d3&rsv_t=68e5dK04hafZNVfCEixDIGedJhu5slXuzXdebsbxpjYiyVYXZoZCKqjWA7w&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=27&rsv_sug1=19&rsv_sug7=100&rsv_sug2=0&inputT=2463&rsv_sug4=2463&rsv_sug=1">2</a>，或者归并排序<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=8b7275410009bcb5&rsv_t=3625sKfYylft69ydnnJ5hh5Z02yhYhUuwnPy22t75oasH4840S/moox+1ks&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=26&rsv_sug1=21&rsv_sug7=100&rsv_sug2=0&inputT=3529&rsv_sug4=3529">3</a>。</p>
<p>后面我们会讲到，归并排序实质上就是cdq分治在二维偏序上的一种应用。而在更高维的三位偏序上，常常采用cdq分治+树状数组的解法。</p>
<h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><p>在这里我们忽略一维情形，因为cdq分治的思想就是降维，一维无维可降故忽略。</p>
<h2 id="二维偏序计数"><a href="#二维偏序计数" class="headerlink" title="二维偏序计数"></a>二维偏序计数</h2><p>以逆序对问题为例，假定这里读者已经完全掌握了归并排序求逆序对<a target="_blank" rel="noopener" href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9&rsv_pq=8b7275410009bcb5&rsv_t=3625sKfYylft69ydnnJ5hh5Z02yhYhUuwnPy22t75oasH4840S/moox+1ks&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=26&rsv_sug1=21&rsv_sug7=100&rsv_sug2=0&inputT=3529&rsv_sug4=3529">3</a>的算法，我们将在此基础上展开讨论。</p>
<h3 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h3><p>要统计数对个数，一种不重复不遗漏的方案是穷举数对中的一个元素，判断另一个元素有几种合法。我们不妨假设要统计数对 $(i,j)$ 的个数，那么对于元素 $j$ ，我们要找出所有和他可比的元素。</p>
<blockquote>
<p>在这里要特别明确一点，本问题中讨论的偏序，指的是各个元素分别满足某种全序关系(在只出现的元素集上满足良序关系)的偏序。比如例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>中，各个属性都是正整数，各个属性内部为全序，可排序。</p>
</blockquote>
<p>那么 $j$ 已经确定，我们归并排序对问题进行分治，那么这个 $i$ 要么和 $j$ 分在同一组中，要么分在另一组中。在常见的分治问题中，往往只需要处理分在同一种中的情况，cdq分治的特性就是将跨组的影响也计算出来，从而将分治的思想引入到偏序计数的问题中。</p>
<p>此时我们在用数据结构保存偏序集中每个元素时，除了要保存元素本身的属性外，还要保存和该元素有关的有序对的数量。在完成算法后，将他们全部取出来求和就是总对数。</p>
<h3 id="以逆序对问题为例"><a href="#以逆序对问题为例" class="headerlink" title="以逆序对问题为例"></a>以逆序对问题为例</h3><p>我们把整个逆序对的元素抽出来，得到一个二维的偏序集，在几何上可以表示为平面上的一堆点。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032217554238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="二维偏序"><br>此时我们使用分治思想，把他们从中间切开，得到左右两部分，如棕色图所示，可以递归处理。我们不妨假设我们此时考虑某个元素 $j&#x3D;5$ ，那么我们实质上要考虑的是有多少 $i$ 满足 $i&lt;j$ 且 $a_i&gt;a_j$。肉眼观察可得有两个，分别是 $i&#x3D;2$ 和 $i&#x3D;4$。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322175906792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 $i&#x3D;4$ 的贡献在分治处理右半边的时候可以得到，所有放心递归即可。而 $i&#x3D;3$ 的贡献还在左半侧，所以需要单独处理。如何处理呢？cdq分治在这里采用的策略就是先排序，后归并。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322180429916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在两侧分别对元素值排序后，实质上我们要统计跨界贡献的就是粉色区域内元素的个数。这个可以很容易在归并排序时做到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            <span class="built_in">add</span>(a[i].z);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个过程中，因为在当前排序的这一元素上是全序的，所以可以排序后归并遍历快速得到结果。我们会发现cdq分治带来了两个log，在分治时带来一个log，在统计跨界元素个数时因为要排序又带来一个log。但是因为这两个log时平行的，所以只需要一个log。而在归并排序求逆序对个数这一特殊问题时，因为归并排序本身可以得到子问题的有序形式，所以在实际操作的时候可以免去排序这一步。但是在cdq分治这一算法框架中排序这一步是必要的。在文章最后总结时我还会给出一个完整的框架，但是到目前为止我们应该已经初窥了cdq分治的奇妙而精巧的转化思想。</p>
<h3 id="更暴力的解法"><a href="#更暴力的解法" class="headerlink" title="更暴力的解法"></a>更暴力的解法</h3><p>不难发现其实本问题可以转化为一个平面上若干个区域内点计数的问题。一个更加暴力的做法是二维线段树或者树套树维护区间和，暴力查询即可，复杂度$O(n log n log n)$</p>
<h2 id="三维偏序计数"><a href="#三维偏序计数" class="headerlink" title="三维偏序计数"></a>三维偏序计数</h2><p>本部分内容以例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>为例。</p>
<h3 id="问题建模-1"><a href="#问题建模-1" class="headerlink" title="问题建模"></a>问题建模</h3><p>先考虑我们的老朋友数形结合，不难发现三位偏序可以把他看成一个立体空间里点计数的问题。暴力做法不难想到，可以三维8叉树暴力求解，或者树套树套树把低维数据结构套成高维的。编程复杂度巨大，显然超出一个智力中等水平的大学生的能力范围。</p>
<p>但是因为我们有了cdq分治这一有利武器，我们可以考虑将问题降维。我们对数组进行如下三步操作：</p>
<p>Step1：按某一维排序<br>Step2：分治解决子问题<br>Step3：解决跨界问题，累计贡献</p>
<p>这也是cdq分治的基本框架。我们可以看到，在离线处理答案的时候，是以贡献累计的方式累加到答案上去的，所以这对问题有一个要求：可独立的叠加和累计。不难发现，计数问题是满足这个条件的，在每个点之间可以互相独立的累计到一起。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>首先按照a轴从小到大排序，这一就得到了一个类似于逆序对的形式：一维有序，另外两维度乱七八糟。现在我们考虑每一个元素作为右元形成的数对，显然只有他左边的点才可能产生贡献，如此我们我们只要统计两部分内容：和他分在一组的和在他左边组的。</p>
<p>和他一组的很好处理，直接递归求解即可。<br>和他不一组的则需要另行处理，这是整个cdq分治中最需要动脑子的部分。</p>
<p>那么怎么处理呢？一个平凡的想法是直接把左半部用二维线段树&#x2F;树套数维护，右半部分查询。或者各自排序再归并，这样保证第一维有序(因为跨过中线，所以就算重排之后a仍然有序)。并且归并第二维也有序，此时直接使用树状数组维护前缀即可。</p>
<p>此处给出例题陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>的AC代码，结合代码进一步讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z,w,ans;</span><br><span class="line">&#125;a[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="type">int</span> n,k,nn;</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x&amp;&amp;a.y==b.y)<span class="keyword">return</span> a.z&lt;b.z;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x)<span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y==b.y?(a.z&lt;b.z):(a.y&lt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWT</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N=maxn&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;N)&#123;</span><br><span class="line">            a[x]+=d;</span><br><span class="line">            x+=x&amp;(-x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            res+=a[x];</span><br><span class="line">            x-=x&amp;(-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l,m);</span><br><span class="line">    <span class="built_in">cdq</span>(m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">sort</span>(a+l,a+m+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="built_in">sort</span>(a+m+<span class="number">1</span>,a+r+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            fwt.<span class="built_in">add</span>(a[i].z,a[i].w);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=fwt.<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;i;++j)fwt.<span class="built_in">add</span>(a[j].z,-a[j].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b,b+n,cmpx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,c=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ++c;</span><br><span class="line">        <span class="keyword">if</span>(b[i].x!=b[i+<span class="number">1</span>].x||b[i].y!=b[i+<span class="number">1</span>].y||b[i].z!=b[i+<span class="number">1</span>].z)&#123;</span><br><span class="line">            a[nn]=b[i];</span><br><span class="line">            a[nn].w=c;</span><br><span class="line">            ++nn;</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">0</span>,nn<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nn;++i)&#123;</span><br><span class="line">        ans[a[i].ans+a[i].w<span class="number">-1</span>]+=a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数内的内容是一些去重的预处理操作，注意cdq分治无法处理有重复元素的问题，原因是在进行不当的划分之后可能漏判一些情况。限于篇幅此处不表，读者可以自行在低维情况下手玩验证。在一般的套路中，其他的操作可视题目情况而定，但是对第一维排序必不可少即可，即Step1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b,b+n,cmpx);</span><br></pre></td></tr></table></figure>
<p>排序后，则可调用cdq分治，核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l,m);</span><br><span class="line">    <span class="built_in">cdq</span>(m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">sort</span>(a+l,a+m+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="built_in">sort</span>(a+m+<span class="number">1</span>,a+r+<span class="number">1</span>,cmpy);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=l,j=m+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].y&lt;=a[j].y&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            fwt.<span class="built_in">add</span>(a[i].z,a[i].w);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j].ans+=fwt.<span class="built_in">ask</span>(a[j].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;i;++j)fwt.<span class="built_in">add</span>(a[j].z,-a[j].w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，若某一时刻当前区间大小为1(代码中均采用闭区间)，那么该空间内部不会产生任何贡献，可以直接return，此为递归的终止边界。由此可见cdq分治是有穷的。</p>
<p>若区间大小不为1，那么必定可以得到两个子问题，直接分治解决即可，此为Step2。</p>
<p>其后则要对跨界内容进行处理，即Step3，首先分别排序，这样在归并时得到的序列在第二维上就是有序的了。此时我们要计算左半边对右半边的贡献，那么第一维度左边总是在右边的左边，分别排序后不会影响此性质，第一维度也相对有序。</p>
<p>这样看似是降低了两个维度，但是其实只降低了一个。我们考虑用树状数组求逆序对的过程，事实上我们是将下标视为时间维度，按照时间顺序维护树状数组和统计答案。对于其他任意的二维偏序问题，我们常见的处理方法是先对其中一维排序，视为时间序，再用树状数组等数据结构维护时间前缀上的信息。而在cdq分治中，我们在分治时保证第一维有序，分别排序保证第二维有序，于是我们按照第二维归并处理时，实质上是按照第二维时间序在操作。通过把点分为两部分，计算左边对右边的贡献，实质上我们在忽略第一维度的情况下得到了第二维的时间序，所以对原问题来说是降低了一个维度。</p>
<h1 id="cdq分治的极限"><a href="#cdq分治的极限" class="headerlink" title="cdq分治的极限"></a>cdq分治的极限</h1><p>各个属性分别满足全序关系的偏序二元对计数问题，我们上面对cdq分治使用的限制条件似乎太过于苛刻了，是否能够将其拓展，使得更多的问题可以由cdq分治解决呢？</p>
<p>答案是肯定的。不难发现，cdq分治是一种时间换维度的算法，而其中必须要满足全序关系的属性其实有且仅有Step1中被排序的一维。换一个角度看，其实cdq分治做的事情是：用一个log的复杂度，将原问题中的时间维消除，转化为一组元素对另一组元素的贡献计数问题。在此基础上，我们再进行归并排序，实质上是再构造一个时间维，而这并不是不可或缺的。</p>
<p>比如在陌上花开<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">1</a>中，我们完全可以先使用cdq分治之后再对左半部分用二维线段树建树，再用右半部分的每个数对二位线段树逐个查询区间和累计答案。这样实质上我们做到了将8叉树(三维线段树)降维到了4叉树(二维线段树)。</p>
<p>而对于其他的问题，其实可以考虑很多种不同的算法和数据结构来维护跨区间的贡献，而他们很多是不要求满足偏序&#x2F;全序关系的，甚至不需要有“序”这个概念，比如有多少对gcd不为1之类。这和很多人提到的cdq分治是在“序”上乱搞的概念不太一样。cdq分治不在序上乱搞，而是消灭一组全序属性。</p>
<h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><h3 id="偏序-全序"><a href="#偏序-全序" class="headerlink" title="偏序+全序"></a>偏序+全序</h3><p>考虑如下问题，给出若干个元素，每个元素有属性a,b，问有多少对数对 $(i,j)$ 满足 $$a_i\leq a_j 且 b_i|b_j$$<br>其中 $x|y$ 表示 $x$ 是 $y$ 的因子。</p>
<p>解决方案比较容易想到，先按照a排序，然后cdq分治。接下来问题就变成如下问题：给定一个集合，里面若干个元素，每个元素有一个属性 $b$ , 若干次查询，问集合中有多少个数是查询数的因子。</p>
<p>暴力一点就左边维护一个hash，右边枚举因子。如果有现成的数据结构和算法也可以很轻松套上去。</p>
<h3 id="求和-全序"><a href="#求和-全序" class="headerlink" title="求和+全序"></a>求和+全序</h3><p>考虑如下问题，给出若干个元素，每个元素有属性a,b，问有多少对数对 $(i,j)$ 满足 $$a_i\leq a_j 且 b_i+b_j&#x3D;K$$</p>
<p>解决方案比较容易想到，先按照a排序，然后cdq分治。接下来问题就变成如下问题：给定一个集合，里面若干个元素，每个元素有一个属性 $b$ , 若干次查询，查询数为 $q$ ，问集合中有多少元素等于 $K-q$ 。</p>
<p>这样问题就变得非常简单，hash即可。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>根据上述两个随手捏的例题，不难得出使用cdq分治的情景：</p>
<ul>
<li>求解合法二元对个数(如果是更多元的话分治时需要更多分类讨论，并不实用，故此处认定只适合二元情形)</li>
<li>有至少一个属性的排序条件为全序关系，或者分段全序(只要满足能够分治且左右两边单向有序即可)</li>
<li>维度较高，简单的数据结构难以维护高维信息</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="cdq分治的思想"><a href="#cdq分治的思想" class="headerlink" title="cdq分治的思想"></a>cdq分治的思想</h2><p>把高维偏序问题降低一个维度，以一个log为代价。</p>
<h2 id="cdq分治的套路"><a href="#cdq分治的套路" class="headerlink" title="cdq分治的套路"></a>cdq分治的套路</h2><p>先对一个维度排序，接下来分治处理贡献：分治解决同块贡献；完事后因为第一维度在分治之后已经保证有序，接下来就变成在左边上统计右边的情况。如果是三维的，那么直接排序+归并即可再减掉一维，这一就减掉了两维，非常轻松的解决掉3维偏序的情况。如果是4维，可以无脑再套一个树套树。据说还可以cdq套cdq，但是目前还没有想明白怎么搞，先咕。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">快速傅里叶变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:06:03 / Modified: 16:06:59" itemprop="dateCreated datePublished" datetime="2022-09-04T16:06:03+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="读这篇文章的前置条件"><a href="#读这篇文章的前置条件" class="headerlink" title="读这篇文章的前置条件"></a>读这篇文章的前置条件</h2><p>1.了解函数，多项式等概念<br>2.了解复数以及其乘法运算<br>3.会写代码(其实不会的人也不会来看这篇文章？)<br>因为在看其他fft的教程的时候复数读完就不知道在说啥了，读了好多篇又抄了std才大致了解，所以通俗的讲一下fft是啥，主要是确定一下概念，梳理一下思路。一些更基础的内容就不再赘述了，如果遇到不知道复数是什么之类的，那可以看一下其他的教程。</p>
<h2 id="什么是FFT"><a href="#什么是FFT" class="headerlink" title="什么是FFT"></a>什么是FFT</h2><p>法法塔(FFT)全称快速傅里叶变换(Fast Fourier Transform),我们经常在求高精度乘法的时候用到这个算法，但是<strong>高精乘只是本身FFT的一种应用</strong>，事实上，傅里叶变换本身只是一种<strong>将多项式在点值表示法和多项式表示法之间转换的方法</strong>。</p>
<h2 id="简单的多项式乘法"><a href="#简单的多项式乘法" class="headerlink" title="简单的多项式乘法"></a>简单的多项式乘法</h2><p>我们考虑一个n次多项式P(x)和另一个m次多项式Q(x)，当我们将x取为10，那么事实上多项式就表示一个十进制数。我们在做乘法的时候，可以将P(x)和Q(x)做卷积，也就是我们日常所用的竖式乘法，得到一个新的多项式A(x)&#x3D;P(x) * Q(x)。对A(x)取x&#x3D;10，就可以得到乘法的结果。这样做的复杂度是O(m * n)。</p>
<h2 id="用点值表示法来进行多项式乘法"><a href="#用点值表示法来进行多项式乘法" class="headerlink" title="用点值表示法来进行多项式乘法"></a>用点值表示法来进行多项式乘法</h2><p>我们上面是在多项式表示法下解决多项式乘法问题，事实上我们还有另一种解决方案。</p>
<p>我们先介绍多项式的<strong>点值表示法</strong>。对于一个n次多项式P(x)，如果我们能在平面上取n+1个点，记为H(x)&#x3D;{(x<sub>1</sub>,y<sub>1</sub>),(x<sub>2</sub>,y<sub>2</sub>)…(x<sub>n+1</sub>,y<sub>n+1</sub>)}，那么我们一定可以定出一个唯一的n次多项式(当然，也可以取更多的点，只要这些点都落在多项式函数上就可以，它等价于一个大于n的次数的系数都为0的更高次多项式，事实上我们在后面操作时的确会取过量个点)。此时我们可以称H(x)和P(x)等价。</p>
<p>那么假设我们现在有两个点值表示法下的多项式H(x),G(x),我们不妨取n&#x3D;(H的次数+y的次数+1)个点，这样我们一定可以正确表示两个小于等于n次的多项式H(x)和G(x)。那么接下来我们可以很快速的求解对应的点值表示法下的多项式：考虑每一个选取的横坐标x，我们有y1&#x3D;H(x),y2&#x3D;G(x),当这这两个多项式的乘积也y3&#x3D;Z(x)一定满足：<center>y3 &#x3D; y1 * y2</center></p>
<p>这个很容易理解，想象一下，当x&#x3D;10时，这不就是我们熟知的乘法吗？只不过是直接在结果上的表现形式罢了。</p>
<p>而因为我们取得点足够多，所以求出来的n个点一定足够表述Z(x)这个多项式方程。<br>这样，我们就可以在O(n+m)时间[两个多项式的长度分别为n，m的情况下]内求解多项式乘法，也就是将这么多个点对应相乘即可。</p>
<p>那么现在我们要解决的问题就是：如何将点值表示法和多项式表示法进行快速的转换。</p>
<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>怎么样把多项式表示法变成点值表示法呢，一个简单的想法是，随便取一些点，求出对应的值，那么就完成了。那么怎么变回去呢？这就是离散傅里叶变换给我们提供的思路：如果我们在将多项式变成点值表示法时取一些特殊的点，那么我们就可以用类似的方法将点值表示法变回多项式表示法。</p>
<p>傅里叶告诉我们，如果我们要取n个点，那么取n次单位复根就会有一个美妙的性质。(如果你是从其他教程过来的，那么应该知道这说的是啥，就不多做赘述了。)<br>接下来讲一下为什么要取这些值呢？</p>
<p>这一篇里面的数学推导非常直白<a target="_blank" rel="noopener" href="https://www.cnblogs.com/RabbitHu/p/FFT.html%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%B0%B1%E7%9B%B4%E6%8E%A5%E7%94%A8%E4%BB%96%E7%9A%84%E5%9B%BE%E4%BA%86%E3%80%82">https://www.cnblogs.com/RabbitHu/p/FFT.html，我这里就直接用他的图了。</a><br><img src="https://img-blog.csdnimg.cn/20190327172940841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70" alt="离散傅里叶变换"><br>这是什么意思呢？<br>意思就是，如果我们取单位负根，那么我们就能用几乎一模一样的函数把点值表示法变回多项式表示法，这是x取单位复根的意义。<strong>事实上，这个单位负根和我们求出来的结果其实没什么关系，这个单纯是用来做变换的手段。</strong><br><img src="https://img-blog.csdnimg.cn/20190327165335990.png" alt="结论"></p>
<h2 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h2><p>但是，直接带入点计算，<del>就算使用高明的秦九韶算法</del> 每个坐标需要O(n)的时间，n个坐标就是O(n^2^)，那么并没有什么用处。这时候，单位负根的另一个性质就得到了体现，我们可以利用分治的思想，将这个过程的时间复杂度降到O(nlogn)。</p>
<p>这就是<strong>快速傅里叶变换FFT</strong>，说白了就是一个<strong>形式转换函数</strong>的<strong>加速版本</strong>。</p>
<p>首先，为了方便起见，我们需要项数为2的幂次，不妨记为n&#x3D;2^k^。研究多项式，有多项式P<sub>n</sub>的最高次为n-1次，超出原多项式的项系数为0，这个我们在上面讨论过。</p>
<p>接下来 我们可以按照奇偶将多项式函数P(x)分成两部分，即:<center>P<sub>n</sub>(x)&#x3D;ODD(x)+EVEN(x)</center></p>
<p>我们将ODD(x)中提出一个x，那么我们得到<center>x * EVEN(x)&#x3D;even(x)</center></p>
<p>联立可以得到:<center>P<sub>n</sub>(x)&#x3D;x * even(x)+EVEN(x)</center></p>
<p>不难发现，偶次项组成的多项式中，我们可以用x^2来代替x，即得到新的</p>
<center>P<sub>n</sub>(x)=A<sub>n/2</sub>(x<sup>2</sup>)+B<sub>n/2</sub>(x<sup>2</sup>)</center> 

<p>其中A和B都是项数减半的多项式。</p>
<p>假设我们现在代入x&#x3D;w<sub>n</sub><sup>k</sup>(当 k &lt; n&#x2F;2时),有：<center>P<sub>n</sub>(w<sub>n</sub><sup>k</sup>)&#x3D;A<sub>n&#x2F;2</sub>(w<sub>n</sub><sup>wk</sup>)+B<sub>n&#x2F;2</sub>(w<sub>n</sub><sup>2k</sup>) * x</center></p>
<p>整理变形得到：<center>P<sub>n</sub>(w<sub>n</sub><sup>k</sup>)&#x3D;A<sub>n&#x2F;2</sub>(w<sub>n</sub><sup>2k</sup>)+B<sub>n&#x2F;2</sub>(w<sub>n</sub><sup>2k</sup>) * w<sub>n</sub><sup>k</sup></center></p>
<p>由单位复根性质可知：<center>w<sub>n</sub><sup>2k</sup>&#x3D;w<sub>n&#x2F;2</sub><sup>k</sup></center><br>即：<center>P<sub>n</sub>(w<sub>n</sub><sup>k</sup>)&#x3D;A<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>)+B<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center></p>
<p>类似地，当n&#x3D;k+n&#x2F;2，我们有:<center>P<sub>n</sub>(w<sub>n</sub><sup>k+n&#x2F;2</sup>)&#x3D;A<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>)+B<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>) * w<sub>n</sub><sup>k+n&#x2F;2</sup></center></p>
<p>整理得到：<center>P<sub>n</sub>(w<sub>n</sub><sup>k+n&#x2F;2</sup>)&#x3D;A<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>)-B<sub>n&#x2F;2</sub>(w<sub>n&#x2F;2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center></p>
<p>综上，我们得到两个递推公式：</p>
<center>P<sub>n</sub>(w<sub>n</sub><sup>k</sup>)=A<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>)+B<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center>

<center>P<sub>n</sub>(w<sub>n</sub><sup>k+n/2</sup>)=A<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>)-B<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center>

<p>从而可以在nlogn时间内进行傅里叶变换。</p>
<h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><p>分治常规的处理方法是递归。但是众所周知，迭代比递归快，所以我们将考虑如何迭代来求解该问题。<br><img src="https://img-blog.csdnimg.cn/20190327215807147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc4MTEw,size_16,color_FFFFFF,t_70" alt="迭代"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二进制翻转数位置</span></span><br><span class="line">	<span class="type">int</span> lim=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;lim)&lt;n)++lim;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lim;++j)<span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)t|=(<span class="number">1</span>&lt;&lt;(lim-j<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;t)<span class="built_in">swap</span>(a[i],a[t]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h2><p>这个操作是什么意思呢？<br>我们有两个式子：</p>
<center>P<sub>n</sub>(w<sub>n</sub><sup>k</sup>)=A<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>)+B<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center>

<center>P<sub>n</sub>(w<sub>n</sub><sup>k+n/2</sup>)=A<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>)-B<sub>n/2</sub>(w<sub>n/2</sub><sup>k</sup>) * w<sub>n</sub><sup>k</sup></center>

<p>但是我们又要同时更新这两个式子，所以怎么办呢？</p>
<p>那么我们另一个新的t等于后项，然后再去分别更新。有点类似于什么呢？大概是swap里面的t的作用。</p>
<p>于是我们就可以在没有buf的情况下计算fft了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> m=l/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(cp *p=a;p!=a+n;p+=l)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">				cp t=omg[n/l*i]*p[i+m];</span><br><span class="line">				p[i+m]=p[i]-t;</span><br><span class="line">				p[i]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度完整代码"><a href="#高精度完整代码" class="headerlink" title="高精度完整代码"></a>高精度完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cp complex<span class="string">&lt;double&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n=<span class="number">1</span>,res[N];</span><br><span class="line">string s1,s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(cp *omg,cp *inv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">		omg[i]=<span class="built_in">cp</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI*i/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI*i/n));</span><br><span class="line">		inv[i]=<span class="built_in">conj</span>(omg[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(cp *a,cp *omg)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lim=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;lim)&lt;n)++lim;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lim;++j)<span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)t|=(<span class="number">1</span>&lt;&lt;(lim-j<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;t)<span class="built_in">swap</span>(a[i],a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> m=l/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(cp *p=a;p!=a+n;p+=l)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">				cp t=omg[n/l*i]*p[i+m];</span><br><span class="line">				p[i+m]=p[i]-t;</span><br><span class="line">				p[i]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line">		cp a[N],b[N],omg[N],inv[N];</span><br><span class="line">		<span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="built_in">sizeof</span>(res));</span><br><span class="line">		<span class="type">int</span> l1=s1.<span class="built_in">length</span>(),l2=s2.<span class="built_in">length</span>();</span><br><span class="line">		n=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n&lt;l1+l2)n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l1;++i)a[i].<span class="built_in">real</span>(s1[l1-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l2;++i)b[i].<span class="built_in">real</span>(s2[l2-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="built_in">init</span>(omg,inv);</span><br><span class="line">		<span class="built_in">fft</span>(a,omg);</span><br><span class="line">		<span class="built_in">fft</span>(b,omg);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)a[i]*=b[i];</span><br><span class="line">		<span class="built_in">fft</span>(a,inv);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			res[i]+=<span class="built_in">floor</span>(a[i].<span class="built_in">real</span>()/n+<span class="number">0.5</span>);</span><br><span class="line">	        res[i+<span class="number">1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">	        res[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;~i;--i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag||res[i])&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				cout&lt;&lt;res[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;                      </span><br><span class="line"></span><br><span class="line">							                                </span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yifan">
      <meta itemprop="description" content="It was the best of times, it was the worst of times.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanshuiii">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/" class="post-title-link" itemprop="url">解不定方程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 15:57:10 / Modified: 16:08:10" itemprop="dateCreated datePublished" datetime="2022-09-04T15:57:10+04:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>传送门：<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1356">http://acm.hdu.edu.cn/showproblem.php?pid=1356</a></p>
<p>由题意，就是要解一个不定方程ax+by&#x3D;d，要求（abs(x)+abs(y)）最小。</p>
<h2 id="一-exgcd"><a href="#一-exgcd" class="headerlink" title="一.exgcd"></a>一.exgcd</h2><p>先从exgcd说起。由裴蜀定理可知，ax+by&#x3D;gcd(a,b)必定存在整数解(x,y)。那么有：</p>
<pre><code>ax+by=gcd(a,b)=gcd(b,a%b)=bx&#39;+(a%b)y&#39;				（1.1）
</code></pre>
<p>其中等号1，3用到了裴蜀定理，等号2用到了gcd的性质。</p>
<p>由a%b&#x3D;a-a&#x2F;b(本文中所有的除法都是整数除法)那么我们把等式最右边变形，可以得到：</p>
<pre><code>ax+by=bx&#39;+ay&#39;-(a/b)y&#39;=ay&#39;+b(x&#39;-(a/b)*y&#39;)			（1.2）
</code></pre>
<p>于是得到一组解：</p>
<pre><code>x=y&#39;								（1.3）
y=x&#39;-(a/b)*y&#39;							（1.4）
</code></pre>
<p>所以可以用递归的方式求解。</p>
<p>最后考虑一下边界条件，当b&#x3D;&#x3D;0时，从线性同余方程的角度看x&#x3D;1，y&#x3D;0显然是一组可行解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;</span><br><span class="line">		x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">	<span class="built_in">swap</span>(x,y);<span class="comment">//此时x=y&#x27;,y=x&#x27;</span></span><br><span class="line">	y-=a/b*x;<span class="comment">//考虑x，y的实际情况，也就是 y=x&#x27;-(a/b)*y&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> d;<span class="comment">//顺便吧gcd也求出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-求通解"><a href="#二-求通解" class="headerlink" title="二.求通解"></a>二.求通解</h2><p>再考虑这道题，等号右边并不是gcd，而是一个d，因为题目告诉你一定有解，所以gcd一定是d的因子，我们把x和y都乘上一个rate&#x3D;(d&#x2F;gcd(a,b)),得到一组初始的</p>
<pre><code>x0=x*rate				（2.1）
y0=y*rate				（2.2）
</code></pre>
<p>接下来就要去找对x0和y0加加减减，来求这个MIN(abs(x0+dx)+abs(y0-dy))。</p>
<p>我们先考虑</p>
<p>再考虑dx和dy的关系：</p>
<pre><code>a*x0+b*y0=d					（2.3）
</code></pre>
<p>对方程变形得到：</p>
<pre><code>a*(x0+dx)+b*(y0-dy)=d				（2.4）
</code></pre>
<p>把里面的式子提出来得到：</p>
<pre><code>a*dx-b*dy=0					（2.5）
</code></pre>
<p>那么就是:</p>
<pre><code>dx/dy=b/a					（2.6）
</code></pre>
<p>考虑gcd(a,b)，可以得到：</p>
<pre><code>dx/dy=(b/gcd)/(a/gcd)				（2.7）
</code></pre>
<p>此时(b&#x2F;gcd)与(a&#x2F;gcd)是互质的所以可以取到的最小的dx和dy就是：</p>
<pre><code>dx=(b/gcd)					（2.8）
dy=(a/gcd)					（2.9）
</code></pre>
<p>那么方程的通解一定满足如下条件：</p>
<pre><code>ansx=x0+k*dx					（2.10）
ansy=y0-k*dy					（2.11）
</code></pre>
<h2 id="三-问题转化"><a href="#三-问题转化" class="headerlink" title="三.问题转化"></a>三.问题转化</h2><p>知道了通解，那么哪一组解才是最优的呢？</p>
<p>因为dx！&#x3D;dy，不妨设dx&gt;dy，我们假设此时x满足</p>
<pre><code>|x|&gt;&gt;|dx|(&gt;&gt;表示远大于)
</code></pre>
<p>那么我们让</p>
<pre><code>x+=t*dx					（3.1）
y-=t*dy					（3.2）
</code></pre>
<p>在x和y均不变号的情况下，答案会变小t*(dx-dy)，是一组更优的解。所以最优解一定满足:</p>
<pre><code>|x|&lt;|dx|				（3.3）
</code></pre>
<p>那么问题就可以转化为变成了求方程关于x的最小正整数解。</p>
<p>但是问题在于，根据式(3.3)，去掉绝对值后，x可能是负的。但是问题在于，我们要求的方程</p>
<pre><code>a*x+b*y=d				(3.4)
</code></pre>
<p>可以变形为</p>
<pre><code>y=(d-a*x)/b				(3.5)
</code></pre>
<p>我们上面已经证明，通过上述方程构造出来的x，上面方程中的y一定是有解的，那么对于一个确定的x，我们总希望y最小，因为dx&gt;dy，那么如果x取到负数，那么一定会大大增加y的值，所以很有可能会更糟。所以我们只要考虑x取最小正整数的情况就可以了。（我直言了，我不会证明，但是我的直觉告诉我这样做很对，oj也告诉我这样做很对）。</p>
<p>反之，如果dy&gt;dx，那么考虑y的最小正整数解即可。</p>
<h2 id="四-求最小正整数解"><a href="#四-求最小正整数解" class="headerlink" title="四.求最小正整数解"></a>四.求最小正整数解</h2><p>那这就非常容易了（说白了就是取模）：</p>
<pre><code>ansx=（ansx%dx+dx）%dx
</code></pre>
<p>然后用式（3.5）：</p>
<pre><code>ansy=(d-a*ansx)/b
</code></pre>
<p>就完事了。</p>
<h2 id="五-贴代码"><a href="#五-贴代码" class="headerlink" title="五.贴代码"></a>五.贴代码</h2><p>看清题意，多写两个if就完事了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(x) (((x)&gt;0)?(x):-(x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x,y,x1,x2,y1,y2,dx,dy;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">	<span class="type">int</span> t=x;x=y,y=t-(a/b)*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,d;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">read</span>(a),<span class="built_in">read</span>(b),<span class="built_in">read</span>(d);</span><br><span class="line">		<span class="keyword">if</span>(!a&amp;&amp;!b&amp;&amp;!d)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> gcd=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">		<span class="type">int</span> rate=d/gcd;</span><br><span class="line">		dx=b/gcd,dy=a/gcd;</span><br><span class="line">		x1=x2=x*rate;</span><br><span class="line">		y1=y2=y*rate;</span><br><span class="line">		x1=(x1%dx+dx)%dx,y1=<span class="built_in">ABS</span>(d-a*x1)/b;</span><br><span class="line">		y2=(y2%dy+dy)%dy,x2=<span class="built_in">ABS</span>(d-b*y2)/a;</span><br><span class="line">		<span class="keyword">if</span>(x1+y1&lt;x2+y2||(x1+y1==x2+y2&amp;&amp;a*x1+b*y1&lt;a*x2+b*y2))cout&lt;&lt;x1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;x2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
